
=encoding utf8

=head1 NOMBRE

perlunicook - recetario de ejemplos del manejo de Unicode en Perl

=head1 DESCRIPCI√ìN

Esta p√°gina de manual contiene unas peque√±as recetas que demuestran c√≥mo manejar las operaciones Unicode m√°s comunes en Perl, m√°s un programa completo, al final. Cualquier variable no declarada en cada receta, se le asume que tiene el apropiado valor anterior.

=head1 EJEMPLOS

=head2 ‚Ñû 0: Pre√°mbulo est√°ndar

A menos que se indique lo contrario, todos los ejemplos siguientes requieren este pre√°mbulo est√°ndar para funcionar correctamente, con el C<#!> ajustado a su sistema:

 #!/usr/bin/env perl

 use utf8;      # los literales e identificadores pueden estar en UTF-8
 use v5.12;     # o siguientes, para activar la caracter√≠stica "unicode_strings"
 use strict;    # entrecomille las cadenas de caracteres, declare las variables
 use warnings;  # activado por defecto
 use warnings  qw(FATAL utf8);    # advertencia fatal en caso de fallos de codificaci√≥n
 use open      qw(:std :utf8);    # los flujos no declarados, en UTF-8
 use charnames qw(:full :short);  # ya no es necesario en v5.16

Esto I<obligar√°>, incluso a los programadores en Unix, a hacer C<binmode> sobre los flujos binarios, o abrirlos con C<:raw>, pero es la √∫nica forma de acceder a ellos de una forma port√°til.

B<ATENCI√ìN>: C<use autodie> (pre 2.26) y C<use open> no se llevan bien, el uno con el otro.

=head2 ‚Ñû 1: Filtro gen√©rico Unicode

Siempre descomponga a la entrada, y luego recomponga a la salida.

 use Unicode::Normalize;

 while (<>) {
     $_ = NFD($_);   # descomponer + reordenar can√≥nicamente
     ...
 } continue {
     print NFC($_);  # recomponer (donde sea posible) + reordenar can√≥nicamente
 }

=head2 ‚Ñû 2: Ajuste fino de las advertencias Unicode

A partir de v5.14, Perl distingue tres subclases de advertencias UTF-8.

 use v5.14;                  # subadvertencias no disponibles en versiones anteriores
 no warnings "nonchar";      # los 66 no-caracteres prohibidos
 no warnings "surrogate";    # el sin sentido UTF-16/CESU-8
 no warnings "non_unicode";  # para c√≥digos de car√°cter superiores a 0x10_FFFF

=head2 ‚Ñû 3: Declare el c√≥digo fuente en UTF-8 para los identificadores y literales

Sin poner la -siempre- criticada declaraci√≥n C<use utf8>, poner UTF-8 en sus literales e identificadores no funcionar√° correctamente.  Si est√° usando el pre√°mbulo est√°ndar indicado antes, s√≠ que funcionar√° bien.  Si lo hace, puede hacer cosas como esta:

 use utf8;

 my $medida    = "√Öngstr√∂m";
 my @Œºsoft     = qw( cp852 cp1251 cp1252 );
 my @·ΩëœÄŒ≠œÅŒºŒµŒ≥Œ±œÇ = qw( ·ΩëœÄŒ≠œÅ  ŒºŒµŒ≥Œ±œÇ );
 my @ÈØâ        = qw( koi8-f koi8-u koi8-r );
 my $motto     = "üë™ üíó üê™"; # FAMILY, GROWING HEART, DROMEDARY CAMEL

Si olvida C<use utf8>, los bytes superiores ser√°n malinterpretados como caracteres individuales, y nada funcionar√° bien.

=head2 ‚Ñû 4: Caracteres y sus n√∫meros

Las funciones C<ord> y C<chr> trabajan transparentemente con todos los c√≥digos de car√°cter, no solo con ASCII, ni siquiera solo con Unicode.

 # caracteres ASCII
 ord("A")
 chr(65)

 # caracteres del Plano Multilenguaje B√°sico (BMP)
 ord("Œ£")
 chr(0x3A3)

 # m√°s all√° de BMP
 ord("ùëõ")               # MATHEMATICAL ITALIC SMALL N
 chr(0x1D45B)

 # ¬°m√°s all√° de Unicode! (hasta el MAXINT)
 ord("\x{20_0000}")
 chr(0x20_0000)

=head2 ‚Ñû 5: Literales Unicode por n√∫mero de car√°cter

En un literal interpolado, bien sea una cadena de caracteres con comillas dobles, o una expresi√≥n regular, puede especificar un car√°cter por su n√∫mero usando el escape C<\x{I<HHHHHH>}>.

 Cadena: "\x{3a3}"
 I<Regex>:  /\x{3a3}/

 Cadena: "\x{1d45b}"
 I<Regex>:  /\x{1d45b}/

 # funciona bien incluso en rangos que no son del BMP
 /[\x{1D434}-\x{1D467}]/

=head2 ‚Ñû 6: Obtener el nombre de un car√°cter a partir de su n√∫mero

 use charnames ();
 my $nombre = charnames::viacode(0x03A3);

=head2 ‚Ñû 7: Obtener el n√∫mero de un car√°cter a partir de su nombre

 use charnames ();
 my $n√∫mero = charnames::vianame("GREEK CAPITAL LETTER SIGMA");

=head2 ‚Ñû 8: Nombres de caracteres Unicode

Use la notaci√≥n C<< \N{I<charname>} >> para obtener el car√°cter correspondiente a ese nombre para usarse en la interpolaci√≥n de literales (cadenas doblemente entrecomilladas y expresiones regulares).  En v5.16, existe un impl√≠cito

 use charnames qw(:full :short);

Pero antes de v5.16, debe explicitar qu√© conjunto de caracteres quiere.  Los nombres C<:full> son los nombres, alias o secuencias de caracteres Unicode oficiales, compartiendo todos el mismo espacio de nombres.

 use charnames qw(:full :short latin greek);

 "\N{MATHEMATICAL ITALIC SMALL N}"      # :full
 "\N{GREEK CAPITAL LETTER SIGMA}"       # :full

Cualquier otra cosa es una abreviatura por conveniencia espec√≠fica de Perl.  Especifique una o m√°s etiquetas si quiere usar nombres abreviados.

 "\N{Greek:Sigma}"                      # :short
 "\N{ae}"                               #  latin
 "\N{epsilon}"                          #  greek

La v5.16 de Perl tambi√©n soporta la importaci√≥n de una etiqueta C<:loose> para poder especificar nombres de caracteres de forma difusa, que funciona como la coincidencia difusa de los nombres de propiedades, es decir, no tiene en cuanta las may√∫sculas/min√∫sculas, espacios en blanco y guiones bajos:

 "\N{euro sign}"                        # :loose (a partir de v5.16)

=head2 ‚Ñû 9: Nombres de secuencias Unicode

Estas se parecen como nombres de caracteres pero devuelven m√∫ltiples c√≥digos de car√°cter.
F√≠jese en el comportamiento de la impresi√≥n de vectores C<%vx> de C<printf>.

 use charnames qw(:full);
 my $seq = "\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}";
 printf "U+%v04X\n", $seq;
 U+0100.0300

=head2 ‚Ñû 10: Nombres de caracteres personalizados

Usar C<:alias> le permite crear sus propios nombres con √°mbito l√©xico, a caracteres actuales, o incluso dar nombres √∫tiles a caracteres de uso privado que no lo tengan.

 use charnames ":full", ":alias" => {
     ecute => "LATIN SMALL LETTER E WITH ACUTE",
     "APPLE LOGO" => 0xF8FF, # car√°cter de uso privado
 };

 "\N{ecute}"
 "\N{APPLE LOGO}"

=head2 ‚Ñû 11: Nombres de c√≥digos de car√°cter CJK

Sinogramas como "Êù±‰∫¨" devuelven nombres de caracteres C<CJK UNIFIED IDEOGRAPH-6771> y C<CJK UNIFIED IDEOGRAPH-4EAC>, porque sus ‚Äúnombres‚Äù var√≠an.  El m√≥dulo de CPAN C<Unicode::Unihan> tiene una gran base de datos para decodificarles (a estos y a muchos m√°s), siempre que sea capaz de entender su salida.

 # cpan -i Unicode::Unihan
 use Unicode::Unihan;
 my $str = "Êù±‰∫¨";
 my $unhan = Unicode::Unihan->new;
 for my $lang (qw(Mandarin Cantonese Korean JapaneseOn JapaneseKun)) {
     printf "CJK $str in %-12s is ", $lang;
     say $unhan->$lang($str);
 }

imprime:

 CJK Êù±‰∫¨ in Mandarin     is DONG1JING1
 CJK Êù±‰∫¨ in Cantonese    is dung1ging1
 CJK Êù±‰∫¨ in Korean       is TONGKYENG
 CJK Êù±‰∫¨ in JapaneseOn   is TOUKYOU KEI KIN
 CJK Êù±‰∫¨ in JapaneseKun  is HIGASHI AZUMAMIYAKO

Si tiene en mente un esquema espec√≠fico de romanizaci√≥n, use el m√≥dulo espec√≠fico:

 # cpan -i Lingua::JA::Romanize::Japanese
 use Lingua::JA::Romanize::Japanese;
 my $k2r = Lingua::JA::Romanize::Japanese->new;
 my $str = "Êù±‰∫¨";
 say "Japanese for $str is ", $k2r->chars($str);

imprime

 Japanese for Êù±‰∫¨ is toukyou

=head2 ‚Ñû 12: De/codificaci√≥n expl√≠cita

En ciertas ocasiones, como al leer de una base de datos, puede recibir texto codificado que necesitar√° decodificar.

  use Encode qw(encode decode);

  my $cars = decode("shiftjis", $bytes, 1);
 # o
  my $bytes = encode("MIME-Header-ISO_2022_JP", $cars, 1);

Para flujos que tengan la misma codificaci√≥n, no use encode/decode; en su lugar active la codiÔ¨Åcaci√≥n cuando abra el archivo o, inmediatamente despu√©s con C<binmode>, tal y como se describe en una receta posterior.

=head2 ‚Ñû 13: Decodificar los argumentos del programa en utf8

     $ perl -CA ...
 o bien
     $ export PERL_UNICODE=A
 o bien
    use Encode qw(decode_utf8);
    @ARGV = map { decode_utf8($_, 1) } @ARGV;

=head2 ‚Ñû 14: Decodificar los argumentos del programa seg√∫n la codificaci√≥n de la configuraci√≥n regional

    # cpan -i Encode::Locale
    use Encode qw(locale);
    use Encode::Locale;

    # use "locale" como un arg. a encode/decode
    @ARGV = map { decode(locale => $_, 1) } @ARGV;

=head2 ‚Ñû 15: Declarar STD{IN,OUT,ERR} para que sean UTF-8

Use una opci√≥n de l√≠nea de comandos, una variable de entorno, o llame expl√≠citamente a C<binmode>:

     $ perl -CS ...
 o bien
     $ export PERL_UNICODE=S
 o bien
     use open qw(:std :utf8);
 o bien
     binmode(STDIN,  ":utf8");
     binmode(STDOUT, ":utf8");
     binmode(STDERR, ":utf8");

=head2 ‚Ñû 16: Declarar STD{IN,OUT,ERR} para que est√©n codificados seg√∫n la configuraci√≥n regional

    # cpan -i Encode::Locale
    use Encode;
    use Encode::Locale;

    # o como un flujo para binmode u open
    binmode STDIN,  ":encoding(console_in)"  if -t STDIN;
    binmode STDOUT, ":encoding(console_out)" if -t STDOUT;
    binmode STDERR, ":encoding(console_out)" if -t STDERR;

=head2 ‚Ñû 17: Hacer la E/S de archivos, por defecto, a utf8

Archivos abiertos sin un argumento de codificaci√≥n, ser√°n en UTF-8:

     $ perl -CD ...
 o bien
     $ export PERL_UNICODE=D
 o bien
     use open qw(:utf8);

=head2 ‚Ñû 18: Hacer que toda la E/S y argumentos est√©n, por defecto, en utf8

     $ perl -CSDA ...
 o bien
     $ export PERL_UNICODE=SDA
 o bien
     use open qw(:std :utf8);
     use Encode qw(decode_utf8);
     @ARGV = map { decode_utf8($_, 1) } @ARGV;

=head2 ‚Ñû 19: Abrir archivo con una codificaci√≥n espec√≠fica

Especifique la codificaci√≥n del flujo.  Esta es la forma normal de gestionar texto codificado, no llamar a funciones de bajo nivel.

 # archivo de entrada
     open(my $in_file, "< :encoding(UTF-16)", "wintext");
 o bien
     open(my $in_file, "<", "wintext");
     binmode($in_file, ":encoding(UTF-16)");
 Y LUEGO
     my $linea = <$in_file>;

 # archivo de salida
     open($out_file, "> :encoding(cp1252)", "wintext");
 o bien
     open(my $out_file, ">", "wintext");
     binmode($out_file, ":encoding(cp1252)");
 Y LUEGO
     print $out_file "alg√∫n texto\n";

Aqu√≠ se pueden especificar m√°s capas aparte de la de codificaci√≥n. Por ejemplo, el conjuro C<":raw :encoding(UTF-16LE) :crlf"> incluye una gesti√≥n CRLF impl√≠cita.

=head2 ‚Ñû 20: Tama√±o de caja en Unicode

La gesti√≥n del tama√±o de caja en Unicode es muy diferente del de ASCII.

 uc("henry ‚Ö∑")  # "HENRY ‚Öß"
 uc("tsch√º√ü")   # "TSCH√úSS"  notice √ü => SS

 # las dos son verdad:
 "tsch√º√ü"  =~ /TSCH√úSS/i   # notice √ü => SS
 "Œ£ŒØœÉœÖœÜŒøœÇ" =~ /Œ£ŒäŒ£Œ•Œ¶ŒüŒ£/i   # note la igualdad de Œ£,œÉ,œÇ

=head2 ‚Ñû 21: Comparaciones Unicode insensibles al tama√±o de caja

Adem√°s del m√≥dulo L<Unicode::CaseFold> disponible en CPAN, la nueva funci√≥n C<fc> "I<foldcase>" (plegado de caja) a partir de v5.16 permite acceder al mismo plegado de caja Unicode que el modificador de patr√≥n C</i> ha usado:

 use feature "fc"; # fc() es funci√≥n desde v5.16

 # ordenaci√≥n insensible al tama√±o de caja
 my @ordenado = sort { fc($a) cmp fc($b) } @lista;

 # las dos son verdad:
 fc("tsch√º√ü")  eq fc("TSCH√úSS")
 fc("Œ£ŒØœÉœÖœÜŒøœÇ") eq fc("Œ£ŒäŒ£Œ•Œ¶ŒüŒ£")

=head2 ‚Ñû 22: Buscar secuencias de ruptura de l√≠nea Unicode con expresiones regulares

Una ruptura de l√≠nea Unicode coincide con el grafema de dos caracteres CRLF o con cualquiera de los siete caracteres verticales de espacio en blanco.
Esto es √∫til para manejarse con ficheros de texto que viene de diferentes sistemas operativos.

 \R

 s/\R/\n/g;  # normalizar todas las rupturas de l√≠nea a \n

=head2 ‚Ñû 23: Obtener la categor√≠a de un car√°cter

Para encontrar la categor√≠a general de un c√≥digo de car√°cter num√©rico.

 use Unicode::UCD qw(charinfo);
 my $cat = charinfo(0x3A3)->{category};  # "Lu"

=head2 ‚Ñû 24: Desactivar la consideraci√≥n Unicode de las clases de caracteres incorporadas

Desactive el funcionamiento Unicode en C<\w>, C<\b>, C<\s>, C<\d>, y en las clases POSIX, tanto en este √°mbito como en una exp. reg.

 use v5.14;
 use re "/a";

 # o

 my($num) = $str =~ /(\d+)/a;

O use propiedades espec√≠ficas para desactivar Unicode, como C<\p{ahex}> y C<\p{POSIX_Digit>}.  Las propiedades siguen trabajando normalmente sin importar qu√© conjunto de modificadores (C</d /u /l /a /aa>) est√©n en activo.

=head2 ‚Ñû 25: Usar propiedades Unicode en expr. reg. con \p, \P

Todas estas coinciden con un c√≥digo de car√°cter con la propiedad indicada.  Use C<\P> en lugar de C<\p> para coincidir con un c√≥digo de car√°cter que no tengo esa propiedad.

 \pL, \pN, \pS, \pP, \pM, \pZ, \pC
 \p{Sk}, \p{Ps}, \p{Lt}
 \p{alpha}, \p{upper}, \p{lower}
 \p{Latin}, \p{Greek}
 \p{script=Latin}, \p{script=Greek}
 \p{East_Asian_Width=Wide}, \p{EA=W}
 \p{Line_Break=Hyphen}, \p{LB=HY}
 \p{Numeric_Value=4}, \p{NV=4}

=head2 ‚Ñû 26: Propiedades de caracteres personalizadas

Para definir en tiempo de compilaci√≥n sus propias propiedades de caracteres personalizadas para usar en exp. reg.

 # usando caracteres de uso privado
 sub In_Tengwar { "E000\tE07F\n" }

 if (/\p{In_Tengwar}/) { ... }

 # mezclando con las propiedades existentes
 sub Is_GraecoRoman_Title {<<'END_OF_SET'}
 +utf8::IsLatin
 +utf8::IsGreek
 &utf8::IsTitle
 END_OF_SET

 if (/\p{Is_GraecoRoman_Title}/ { ... }

=head2 ‚Ñû 27: Normalizaci√≥n Unicode

T√≠picamente, deber√≠a mostrar sus datos en NFD (la forma de descomposici√≥n can√≥nica) en la entrada y en NFC (descomposici√≥n can√≥nica seguido por una composici√≥n can√≥nica) en la salida. Usar las funciones NFKC o NFKD mejora las prestaciones en las b√∫squedas, asumiendo que haya hecho la misma normalizaci√≥n al texto a localizarse. Note que esta normalizaci√≥n es m√°s que solo dividir y unir precombinados glifos compatibles; tambi√©n reordena marcas de acuerdo a las clases de combinaci√≥n can√≥nica y poda a los que queden sueltos.

 use Unicode::Normalize;
 my $nfd  = NFD($orig);
 my $nfc  = NFC($orig);
 my $nfkd = NFKD($orig);
 my $nfkc = NFKC($orig);

=head2 ‚Ñû 28: Convertir valores num√©ricos Unicode no-ASCII

A menos que haya usado C</a> o C</aa>, C<\d> coincide con muchos m√°s caracteres que solo los d√≠gitos ASCII, pero la conversi√≥n de Perl impl√≠cita de cadena a n√∫mero, actualmente, no los reconoce.  Aqu√≠ indicaremos c√≥mo convertir estas cadenas de forma manual.

 use v5.14;  # necesario para la funci√≥n num()
 use Unicode::UCD qw(num);
 my $str = "tengo ‚Ö´ y ‡•™‡•´‡•¨‡•≠ y ‚Öû y as√≠";
 my @nums = ();
 while ($str =~ /(\d+|\N)/g) {  # ¬°No solo ASCII!
    push @numeros, num($1);
 }
 say "@numeros";   #     12      4567      0.875

 use charnames qw(:full);
 my $nv = num("\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}");

=head2 ‚Ñû 29: Coincidir con agrupaciones de grafemas Unicode en exp. reg.

Los "caracteres" visibles para el programador son c√≥digos de car√°cter que coinciden con C</./s>, pero los "caracteres" visibles para el usuario son los grafemas que coinciden con C</\X/>.

 # Busca vocal *m√°s* cualquier combinaci√≥n con diacr√≠tico, subrayado, etc.
 my $nfd = NFD($original);
 $nfd =~ / (?=[aeiou]) \X /xi

=head2 ‚Ñû 30: Extraer por grafema en lugar de por c√≥digo de car√°cter (exp.reg.)

 # coincide y captura los cinco primeros grafemas
 my($cinco_primeros) = $cadena =~ /^ ( \X{5} ) /x;

=head2 ‚Ñû 31: Extraer por grafema en lugar de por c√≥digo de car√°cter (substr)

 # cpan -i Unicode::GCString
 use Unicode::GCString;
 my $gcs = Unicode::GCString->new($str);
 my $cinco_primeros = $gcs->substr(0, 5);

=head2 ‚Ñû 32: Invertir una cadena por sus grafemas

Invertir una cadena por c√≥digos de car√°cter mezcla los diacr√≠ticos, convirtiendo err√≥neamente C<cr√®me br√ªl√©e> en C<√©elÃÇurb emÃÄerc> en lugar de C<e√©l√ªrb em√®rc>.  Estas dos aproximaciones funcionan correctamente sin importar en qu√© normalizaci√≥n se encuentre la cadena:

 $str = join("", reverse $str =~ /\X/g);

 # o cpan -i Unicode::GCString
 use Unicode::GCString;
 $str = reverse Unicode::GCString->new($str);

=head2 ‚Ñû 33: Longitud de la cadena en grafemas

La cadena C<br√ªl√©e> tiene seis grafemas pero tambi√©n hasta ocho c√≥digos de car√°cter.
Esto cuenta por grafemos, no por c√≥digos de car√°cter:

 my $str = "br√ªl√©e";
 my $cuenta = 0;
 while ($str =~ /\X/g) { $cuenta++ }

  # o cpan -i Unicode::GCString
 use Unicode::GCString;
 my $gcs = Unicode::GCString->new($str);
 my $cuenta = $gcs->length;

=head2 ‚Ñû 34: Impresi√≥n de columnas de ancho fijo en Unicode

Las funciones integradas de Perl C<printf>, C<sprintf> y C<format>, creen que todos los c√≥digos de car√°cter ocupan una columna de impresi√≥n, pero muchos de ellos toman 0 o 2.
Para mostrar que la normalizaci√≥n no produce ninguna diferencia, imprimiremos de ambas formas:

 use Unicode::GCString;
 use Unicode::Normalize;

 my @words = qw/cr√®me br√ªl√©e/;
 @words = map { NFC($_), NFD($_) } @words;

 for my $str (@words) {
     my $gcs = Unicode::GCString->new($str);
     my $cols = $gcs->columns;
     my $pad = " " x (10 - $cols);
     say str, $pad, " |";
 }

... genera esto, para mostrar que rellena correctamente sin importar de qu√© normalizaci√≥n sea:

 cr√®me      |
 cr√®me      |
 br√ªl√©e     |
 br√ªl√©e     |

=head2 ‚Ñû 35: Cotejo Unicode

Un texto ordenado por la numeraci√≥n de los c√≥digos de car√°cter no sigue un orden alfab√©tico razonable; use la UCA (I<Unicode Collation Algorithm>) para la ordenaci√≥n de texto.

 use Unicode::Collate;
 my $col = Unicode::Collate->new();
 my @list = $col->sort(@old_list);

Vea el programa I<ucsort> del m√≥dulo CPAN L<Unicode::Tussle> para ver un interfaz apropiado para la l√≠nea de comandos para este m√≥dulo.

=head2 ‚Ñû 36: Ordenaci√≥n Unicode independiente del tama√±o de caja y de las tildes

Especifique una fuerza de cotejo de nivel 1 para ignorar el tama√±o de caja y los diacr√≠ticos, para examinar solo los caracteres b√°sicos.

 use Unicode::Collate;
 my $col = Unicode::Collate->new(level => 1);
 my @list = $col->sort(@old_list);

=head2 ‚Ñû 37: Cotejo Regional Unicode

Algunas configuraciones regionales tienen reglas especiales de ordenaci√≥n.

 # o bien use v5.12, o bien: cpan -i Unicode::Collate::Locale
 use Unicode::Collate::Locale;
 my $col = Unicode::Collate::Locale->new(locale => "de__phonebook");
 my @list = $col->sort(@old_list);

El programa I<ucsort> mencionado antes acepta un par√°metro C<--locale>.

=head2 ‚Ñû 38: Hacer que C<cmp> trabaje con texto en lugar de con c√≥digos de car√°cter

As√≠ que en vez de esto:

 @srecs = sort {
     $b->{AGE}   <=>  $a->{AGE}
                 ||
     $a->{NAME}  cmp  $b->{NAME}
 } @recs;

Use esto:

 my $coll = Unicode::Collate->new();
 for my $rec (@recs) {
     $rec->{NAME_key} = $coll->getSortKey( $rec->{NAME} );
 }
 @srecs = sort {
     $b->{AGE}       <=>  $a->{AGE}
                     ||
     $a->{NAME_key}  cmp  $b->{NAME_key}
 } @recs;

=head2 ‚Ñû 39: Comparaci√≥n insensible al tama√±o de caja y a los diacr√≠ticos

Use un objeto cotejador para comparar texto Unicode de car√°cter en car√°cter en lugar de por c√≥digo de car√°cter.

 use Unicode::Collate;
 my $es = Unicode::Collate->new(
     level => 1,
     normalization => undef
 );

  # ahora estas dos son verdaderas:
 $es->eq("Garc√≠a",  "GARCIA" );
 $es->eq("M√°rquez", "MARQUEZ");

=head2 ‚Ñû 40: Comparaci√≥n regional insensible al tama√±o de caja y a los diacr√≠ticos

Lo mismo, pero en una configuraci√≥n regional espec√≠fica.

 my $de = Unicode::Collate::Locale->new(
            locale => "de__phonebook",
          );

 # ahora esto es verdadero:
 $de->eq("tsch√º√ü", "TSCHUESS");  # note que √º => UE, √ü => SS

=head2 ‚Ñû 41: Ruptura de l√≠neas en Unicode

Divide el texto en l√≠neas de acuerdo a las reglas Unicode.

 # cpan -i Unicode::LineBreak
 use Unicode::LineBreak;
 use charnames qw(:full);

 my $para = "This is a super\N{HYPHEN}long string. " x 20;
 my $fmt = Unicode::LineBreak->new;
 print $fmt->break($para), "\n";

=head2 ‚Ñû 42: Texto Unicode en hash DBM, forma tediosa

Usar una cadena normal Perl como una clave o un valor para un hash DBM lanzar√° una excepci√≥n sobre que se ha encontrado un car√°cter ancho, si alg√∫n c√≥digo de car√°cter no entra en un byte.  Aqu√≠ est√° la manera de c√≥mo gestionar manualmente la traslaci√≥n:

    use DB_File;
    use Encode qw(encode decode);
    tie %dbhash, "DB_File", "ruta_al_archivo";

 # STORE

    # asumimos que $uni_clave y $uni_valor son cadenas Unicode abstractas
    my $enc_clave = encode("UTF-8", $uni_clave, 1);
    my $enc_valor = encode("UTF-8", $uni_valor, 1);
    $dbhash{$enc_clave} = $enc_valor;

 # FETCH

    # asumimos que $uni_clave contiene una cadena normal Perl (Unicode abstracta)
    my $enc_clave = encode("UTF-8", $uni_clave, 1);
    my $enc_valor = $dbhash{$enc_clave};
    my $uni_valor = decode("UTF-8", $enc_valor, 1);

=head2 ‚Ñû 43: Texto Unicode en hash DBM, forma f√°cil

Aqu√≠ se muestra c√≥mo gestionar impl√≠citamente la traducci√≥n; todo el codificado y decodificado se hace autom√°ticamente, igual que si fueran flujos configurados con una codificaci√≥n particular:

    use DB_File;
    use DBM_Filter;

    my $dbobj = tie %dbhash, "DB_File", "ruta_al_archivo";
    $dbobj->Filter_Value("utf8");  # este es el punto m√°gico

 # STORE

    # asumimos que $uni_clave y $uni_valor son cadenas Unicode abstractas
    $dbhash{$uni_clave} = $uni_valor;

  # FETCH

    # $uni_clave contiene una cadena Perl normal (Unicode abstracta)
    my $uni_valor = $dbhash{$uni_clave};

=head2 ‚Ñû 44: PROGRAMA: Demo de cotejo Unicode e impresi√≥n

Aqu√≠ hay un programa completo que muestra c√≥mo hacer uso de la ordenaci√≥n sensible a la configuraci√≥n regional, tama√±o de caja seg√∫n Unicode, y gesti√≥n de la impresi√≥n de distintos anchos cuando alguno de los caracteres toman cero o dos columnas, no solo una columna cada vez.
Cuando lo ejecute, el programa produce una bonita salida alineada:

    Cr√®me Br√ªl√©e....... ‚Ç¨2.00
    √âclair............. ‚Ç¨1.60
    Fideu√†............. ‚Ç¨4.20
    Hamburger.......... ‚Ç¨6.00
    Jam√≥n Serrano...... ‚Ç¨4.45
    Lingui√ßa........... ‚Ç¨7.00
    P√¢t√©............... ‚Ç¨4.15
    Pears.............. ‚Ç¨2.00
    P√™ches............. ‚Ç¨2.25
    Sm√∏rbr√∏d........... ‚Ç¨5.75
    Sp√§tzle............ ‚Ç¨5.50
    Xori√ßo............. ‚Ç¨3.00
    ŒìœçœÅŒøœÇ.............. ‚Ç¨6.50
    ÎßâÍ±∏Î¶¨............. ‚Ç¨4.00
    „Åä„ÇÇ„Å°............. ‚Ç¨2.65
    „ÅäÂ•Ω„ÅøÁÑº„Åç......... ‚Ç¨8.00
    „Ç∑„É•„Éº„ÇØ„É™„Éº„É†..... ‚Ç¨1.85
    ÂØøÂè∏............... ‚Ç¨9.99
    ÂåÖÂ≠ê............... ‚Ç¨7.50

Aqu√≠ est√° el programa, testado en v5.14.

 #!/usr/bin/env perl
 # umenu - demo de ordenaci√≥n e impresi√≥n de comida Unicode
 #
 # (obligatorio y, cada vez m√°s largo, pre√°mbulo)
 #
 use utf8;
 use v5.14;                       # para la ordenaci√≥n seg√∫n la configuraci√≥n regional
 use strict;
 use warnings;
 use warnings  qw(FATAL utf8);    # hace fatales los fallos de codificaci√≥n
 use open      qw(:std :utf8);    # los flujos no declarados, en UTF-8
 use charnames qw(:full :short);  # ya no es necesario en v5.16

 # m√≥dulos est√°ndar
 use Unicode::Normalize;          # est√°ndar en la distribuci√≥n perl v5.8
 use List::Util qw(max);          # est√°ndar en la distribuci√≥n perl v5.10
 use Unicode::Collate::Locale;    # est√°ndar en la distribuci√≥n perl v5.14

 # m√≥dulos cpan
 use Unicode::GCString;           # desde CPAN

 # declaraciones previas
 sub pad($$$);
 sub colwidth(_);
 sub entitle(_);

 my %price = (
     "Œ≥œçœÅŒøœÇ"             => 6.50, # gyros, Griego
     "pears"             => 2.00, # algo as√≠ como, peras
     "lingui√ßa"          => 7.00, # salchicha picante, Portuguese
     "xori√ßo"            => 3.00, # chorizo, Catal√°n
     "hamburger"         => 6.00, # burgermeister meisterburger
     "√©clair"            => 1.60, # postre, French
     "sm√∏rbr√∏d"          => 5.75, # sandwiches, Norwegian
     "sp√§tzle"           => 5.50, # Bayerisch noodles, little sparrows
     "ÂåÖÂ≠ê"              => 7.50, # bao1 zi5, steamed pork buns, Mandarin
     "jam√≥n serrano"     => 4.45, # jam√≥n serrano, Spanish
     "p√™ches"            => 2.25, # peaches, French
     "„Ç∑„É•„Éº„ÇØ„É™„Éº„É†"    => 1.85, # cream-filled pastry like eclair
     "ÎßâÍ±∏Î¶¨"            => 4.00, # makgeolli, Korean rice wine
     "ÂØøÂè∏"              => 9.99, # sushi, Japanese
     "„Åä„ÇÇ„Å°"            => 2.65, # omochi, rice cakes, Japanese
     "cr√®me br√ªl√©e"      => 2.00, # crema catalana
     "fideu√†"            => 4.20, # more noodles, Valencian
                                  # (Catalan=fideuada)
     "p√¢t√©"              => 4.15, # gooseliver paste, French
     "„ÅäÂ•Ω„ÅøÁÑº„Åç"        => 8.00, # okonomiyaki, Japanese
 );

 my $width = 5 + max map { colwidth } keys %price;

 # El material asi√°tico sale en un orden que alguien
 # que lea esta salida no se asuste; el
 # CJK estar√° entonces en orden JIS X 0208.
 my $coll  = Unicode::Collate::Locale->new(locale => "ja");

 for my $item ($coll->sort(keys %price)) {
     print pad(entitle($item), $width, ".");
     printf " ‚Ç¨%.2f\n", $price{$item};
 }

 sub pad($$$) {
     my($str, $width, $padchar) = @_;
     return $str . ($padchar x ($width - colwidth($str)));
 }

 sub colwidth(_) {
     my($str) = @_;
     return Unicode::GCString->new($str)->columns;
 }

 sub entitle(_) {
     my($str) = @_;
     $str =~ s{ (?=\pL)(\S)     (\S*) }
              { ucfirst($1) . lc($2)  }xge;
     return $str;
 }

=head1 VEA TAMBI√âN

Vea estas p√°ginas de manual, algunas de ellas son de m√≥dulos CPAN:
L<perlunicode>, L<perluniprops>,
L<perlre>, L<perlrecharclass>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>,
L<PerlIO>, L<DB_File>, L<DBM_Filter>, L<DBM_Filter::utf8>,
L<Encode>, L<Encode::Locale>,
L<Unicode::UCD>,
L<Unicode::Normalize>,
L<Unicode::GCString>, L<Unicode::LineBreak>,
L<Unicode::Collate>, L<Unicode::Collate::Locale>,
L<Unicode::Unihan>,
L<Unicode::CaseFold>,
L<Unicode::Tussle>,
L<Lingua::JA::Romanize::Japanese>,
L<Lingua::ZH::Romanize::Pinyin>,
L<Lingua::KO::Romanize::Hangul>.

El m√≥dulo CPAN L<Unicode::Tussle> incluye muchos programas para ayudar en el trabajo con Unicode, incluyendo estos programas que reemplazan parcial o totalmente de utilidades est√°ndar:
I<tcgrep> en lugar de I<egrep>,
I<uniquote> en lugar de I<cat -v> o I<hexdump>,
I<uniwc> en lugar de I<wc>,
I<unilook> en lugar de I<look>,
I<unifmt> en lugar de I<fmt>,
y
I<ucsort> en lugar de I<sort>.
Para explorar nombres de caracteres Unicode y propiedades de caracteres, vea los programas I<uniprops>, I<unichars> y I<uninames>.
Tambi√©n ofrece programas que son filtros generales pero con soporte Unicode:
I<unititle> y I<unicaps>;
I<uniwide> y I<uninarrow>;
I<unisupers> y I<unisubs>;
I<nfd>, I<nfc>, I<nfkd> y I<nfkc>;
y I<uc>, I<lc> y I<tc>.

Finalmente, vea la √∫ltima publicaci√≥n del Est√°ndar Unicode (los n√∫meros de p√°gina son desde la versi√≥n 6.0.0), incluyendo los anexos espec√≠ficos e informes t√©cnicos:

=over

=item ¬ß3.13 Default Case Algorithms, p√°gina 113;
¬ß4.2  Case, p√°ginas 120‚Äì122;
Case Mappings, p√°gina 166‚Äì172, especialmente Caseless Matching comenzando en la p√°gina 170.

=item UAX #44: Unicode Character Database

=item UTS #18: Unicode Regular Expressions

=item UAX #15: Unicode Normalization Forms

=item UTS #10: Unicode Collation Algorithm

=item UAX #29: Unicode Text Segmentation

=item UAX #14: Unicode Line Breaking Algorithm

=item UAX #11: East Asian Width

=back

=head1 AUTOR

Tom Christiansen E<lt>tchrist@perl.comE<gt> escribi√≥ esto, con alguna pizca asistencial de Larry Wall y Jeffrey Friedl por detr√°s.

=head1 COPYRIGHT Y LICENCIA

Copyright ¬© 2012 Tom Christiansen.

Este programa es software libre; puede redistribuirlo o modificarlo en los mismos t√©rminos que el propio Perl.

La mayor parte de estos ejemplos vienen de la actual edici√≥n del "Libro del Camello", es decir, de la 4¬™ edici√≥n de I<Programming Perl>, Copyright ¬© 2012 Tom Christiansen y otros, 2012-02-13 de O'Reilly Media.  El c√≥digo es libremente redistribuible, y se recomienda trasplantar, doblar, dividir y mutilar cualquiera de los ejemplos de esta p√°gina de manual, como quiera que sea, para ser incluidos en sus propios programas sin ning√∫n tipo de gravamen alguno.
Un reconocimiento a trav√©s de un comentario en el c√≥digo es algo cort√©s, pero no requerido.

=head1 HISTORIA DE REVISIONES

v1.0.0 ‚Äì primera publicaci√≥n p√∫blica, 2012-02-27
