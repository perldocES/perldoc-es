=head1 NOMBRE

perldata - Tipos de datos de Perl

=head1 DESCRIPCIÓN

=head2 Nombres de variables
X<variable, name> X<variable name> X<data type> X<type>
X<variable, nombre> X<nombre de variable> X<tipo de datos> X<tipo>

Perl tiene tres tipos de datos predefinidos: escalares, arrays de escalares y arrays asociativos de escalares (denominados "hashes").  Un escalar es una cadena (de cualquier tamaño, limitado únicamente por la memoria disponible), un número o una referencia a algo (las referencias se describen en L<perlref>).  Los arrays normales son listas ordenadas de escalares indexadas por números, empezando por 0.  Los hashes son colecciones no ordenadas de valores escalares indexadas por sus claves asociadas, que son cadenas de caracteres.

A los valores se accede normalmente por su nombre, o a través de una referencia con nombre.
El primer carácter del nombre nos indica el tipo de la estructura de datos.  El resto del nombre indica a qué valor concreto se accede.  Normalmente, este nombre es un I<identificador>, es decir, una palabra que comienza por una letra o un guión bajo, y que contiene letras, guiones bajos o dígitos.  En ciertos casos, puede ser una serie de identificadores separados por C<::> (o por el separador C<'>, algo anticuado), donde todos los identificadores menos el último se interpretan como nombres de paquetes que determinan el espacio de nombres en el que se buscará el identificador final (encontrará más detalles en la sección "Paquetes" de L<perlmod>).  Para una explicación más detallada
de los identificadores, vea L<Análisis de identificadores>.  También es posible sustituir un identificador simple por una expresión que produzca una referencia al valor en tiempo de ejecución.   Esto se describe con mayor detalle más abajo y en L<perlref>.
X<identifier> X<identificador>

Perl también tiene sus propias variables predefinidas, cuyos nombres no siguen estas reglas.  Estas variables tienen nombres extraños para evitar conflictos accidentales con las variables normales.  Las cadenas que coinciden con las partes encerradas entre paréntesis de una expresión regular se guardan con nombres que contienen solo dígitos después del símbolo C<$> (véase L<perlre> y L<perlop>).
Por otra parte, varias variables especiales que proporcionan acceso al medio interno de Perl tienen nombres que contienen caracteres de puntuación.
Se describen en L<perlvar>.
X<variable, built-in> X<variable, predefinida>

Si un nombre de variable empieza por "$", indica que la variable contiene un valor escalar; puede ser un escalar que forma parte de un array o un hash.  Desde el punto de vista semántico, el signo "$" desempeña la misma función que la palabra "el" o "la" en español; es decir, indica que se espera un único valor.
X<scalar> X<escalar>

    $jornadas        # el valor escalar único llamado "jornadas"
    $jornadas[28]    # el elemento número 29 del array @jornadas
    $jornadas{'Feb'} # el valor 'Feb' del hash %jornadas
    $#jornadas       # el último índice del array @jornadas

Se usa el carácter "@" para indicar que una variable es un array completo (o una porción de array o hash). Funciona de manera parecida a las palabras "estos/esos" o "estas/esas" del español, que indican que se esperan múltiples valores.
X<array>

    @jornadas		# ($jornadas[0], $jornadas[1],... $jornadas[n])
    @jornadas[3,4,5]	# igual que ($jornadas[3],$jornadas[4],$jornadas[5])
    @jornadas{'a','c'}	# igual que ($jornadas{'a'},$jornadas{'c'})

Para designar variables que contienen hashes completos, se usa el carácter "%": X<hash>

    %jornadas		# (clave1, valor1, clave2, valor2 ...)

Por otra parte, se usa el carácter "&" para designar subrutinas, aunque esto es opcional cuando no haya ambigüedad, igual que el sujeto de una frase en español es a menudo redundante cuando va implícito en el verbo, como en "(yo) tengo lo que usted necesita".  Las entradas de la tabla de símbolos pueden designarse con un carácter "*" inicial, aunque no hace falta que se preocupe por esto de momento (y quizá no tenga que hacerlo nunca:-)).

Cada tipo de variable tiene su propio espacio de nombres, al igual que otros tipos de identificadores que no designan variables.  Esto significa que se puede utilizar el mismo nombre para una variable escalar, un array o un hash sin que se produzcan conflictos; o, por la misma razón, se puede utilizar el mismo nombre para un identificador de archivo, un identificador de directorio, el nombre de una subrutina, un nombre de formato o una etiqueta.  Esto quiere decir que $foo y @foo son dos variables distintas.  También significa que C<$foo[1]> forma parte de @foo, no de $foo.  Esto puede parecerle un poco raro, pero no debe preocuparse: es raro.
X<namespace> X<espacio de nombres>

Puesto que los nombres de variables siempre empiezan por "$", "@" o "%", las palabras "reservadas", de hecho, no están reservadas con respecto a los nombres de variables.  Sin embargo, I<sí están reservadas> con respecto a las etiquetas y los identificadores de archivo, ya que los nombres de estos no requieren usar un carácter especial inicial.  Por ejemplo, no se puede usar un identificador de archivo llamado "log".  Un consejo: es mejor escribir C<open(LOG,'archivo_log')> que C<open(log,'archivo_log')>.  El uso de identificadores de archivo en mayúsculas mejora la legibilidad de los programas y les protege de conflictos con futuras palabras reservadas.  Se distinguen mayúsculas de minúsculas: "FOO", "Foo" y "foo" se consideran nombres diferentes.  Los nombres que empiezan por una letra o un guión bajo pueden incluir también dígitos y otros guiones bajos.
X<identifier, case sensitivity> X<case> X<identificador, distinguir mayúsculas de minúsculas> X<mayúsculas y minúsculas>

Es posible sustituir cualquier nombre alfanumérico por una expresión que devuelva una referencia al tipo apropiado.  Encontrará una descripción de esto en L<perlref>.

Los nombres que comienzan con un dígito solo pueden contener otros dígitos.  Los nombres que no empiecen por una letra, un guión bajo, un dígito o un circunflejo, se limitan a un solo carácter, como por ejemplo C<$%> o C<$$>.  (la mayor parte de estos nombres de un solo carácter tienen un significado predefinido para Perl;  Por ejemplo, C<$$> es el ID del proceso actual.  Y todos estos nombre se reservan para un posible uso de Perl).

=head2 Interpretación de identificadores
X<identifiers> X<identificadores>

Hasta Perl 5.18, las reglas actuales de lo que es un identificador válido, no estaban claras.  Aun así, y de forma general, cualquier cosa definida aquí tendría que trabajar en versiones anteriores de Perl, mientras que lo opuesto -casos límite que funcionan en versiones anteriores, pero no definidos aquí- probablemente no funcionarán en las nuevas versiones.
Como detalle importante, por favor, note que lo siguiente sólo se aplica a identificadores de palabras simples encontrados en código fuente Perl, no en identificadores creados a partir de referencias simbólicas, los cuales tienen muchas menos
restricciones.
Si se está trabajando bajo el efecto del pragma C<use utf8;>, se aplican las siguientes reglas:

    / (?[ ( \p{Word} & \p{XID_Start} ) + [_] ])
      (?[ ( \p{Word} & \p{XID_Continue} ) ]) *    /x

Es decir, un carácter de "inicio" seguido de cualquier número de caracteres de "continuación".  Perl requiere que cada carácter, en un identificador, coincida también con C<\w> (esto impide algunos casos problemáticos) y Perl, acepta, además, nombres de identificadores que comiencen con un guión bajo.

Si no se está bajo C<use utf8>, el código fuente se trata como ASCII + 128 caracteres genéricos extra, y los identificadores tendrán que coincidir con

    / (?aa) (?!\d) \w+ /x

Es decir, cualquier carácter de palabra en el rango del ASCII, mientras que el primer carácter no sea un dígito.

Hay dos separadores de paquete en Perl: Dos caracteres de dos puntos (C<::>) y una comilla simple (C<'>).  Los identificadores normales pueden empezar o terminar con un doble carácter de dos puntos, y puede contener varias partes delimitadas por estos caracteres.
Las comillas simples tienen reglas similares, pero con la excepción de que no son legales al final de un identificador: es decir, C<$'foo> y C<$foo'bar> son legales, pero C<$foo'bar'> no lo es.

Además, si el identificador está precedido por un sigilo -es decir, si el identificador es parte de un nombre de variable- opcionalmente puede encerrarse entre llaves.

Mientras que puede mezclar los dobles dos puntos con comillas simples, éstas tienen que venir a continuación de los dobles dos puntos: C<$::::'foo> y C<$foo::'bar> son legales, pero C<$::'::foo> y C<$foo'::bar> no lo son.

Puesto todo junto, una gramática que coincida con un identificador básico deviene así

 /
  (?(DEFINE)
      (?<variable>
          (?&sigilo)
          (?:
                  (?&identificador_normal)
              |   \{ \s* (?&identificador_normal) \s* \}
          )
      )
      (?<identificador_normal>
          (?: :: )* '?
           (?&identificador_basico)
           (?: (?= (?: :: )+ '? | (?: :: )* ' ) (?&identificador_normal) )?
          (?: :: )*
      )
      (?<identificador_basico>
        # ¿está use utf8 activado?
          (?(?{ (caller(0))[8] & $utf8::hint_bits })
              (?&Perl_XIDS) (?&Perl_XIDC)*
            | (?aa) (?!\d) \w+
          )
      )
      (?<sigilo> [&*\$\@\%])
      (?<Perl_XIDS> (?[ ( \p{Word} & \p{XID_Start} ) + [_] ]) )
      (?<Perl_XIDC> (?[ \p{Word} & \p{XID_Continue} ]) )
  )
 /x

Entretanto, los identificadores especiales no siguen las reglas anteriores; la mayor parte de los identificadores de esta categoría tienen un significado especial para Perl.  Debido a que tienen reglas de interpretación especiales, de forma general no pueden cualificarse plenamente.  Vienen en seis formas (pero no use las formas 5 y 6):

=over

=item 1.

Un sigilo, seguido únicamente por dígitos, coincidiendo con \p{POSIX_Digit}, como C<$0>, C<$1>, o C<$10000>.

=item 2.

Un sigilo seguido por un único carácter coincidente con la propiedad C<\p{POSIX_Punct}>, como C<$!> o C<%+>, excepto el carácter C<"{">, no funciona.

=item 3.

Un sigilo, seguido por un circunflejo, y cualquiera de los caracteres C<[][A-Z^_?\]>, como C<$^V> o C<$^]>.

=item 4.

De forma similar a lo anterior, un sigilo, seguido por un texto simple, entre llaves, donde el primer carácter es un circunflejo.  El siguiente carácter es cualquiera de los caracteres C<[][A-Z^_?\]>, seguido por caracteres ASCII que formen parte de una palabra.  Un ejemplo es C<${^GLOBAL_PHASE}>.

=item 5.

Un sigilo, seguido por un único carácter en el rango C<[\x80-\xFF]> cuando no esté activado C<S<"use utf8">>.  (Bajo C<S<"use utf8">>, se aplican las reglas normales sobre identificadores que se indicaron al principio de esta sección).  Uso de caracteres no gráficos (los caracteres de control C1, el NO-BREAK SPACE y el SOFT HYPHEN) están obsoletos y se prohibirán en una futura versión de Perl.  El uso del resto de caracteres no está aconsejado, ya que todos están reservados para un uso especial de Perl; ninguno de ellos, actualmente, lo tienen, aunque esto puede cambiar en el futuro, sin previo aviso.

Note que esta forma implica que existen identificadores que son legales solo bajo C<S<"use utf8">>, y viceversa; por ejemplo el identificador C<$E<233>tat> es legal bajo C<S<"use utf8">>, pero de lo contrario se considera que es una única variable de un solo carácter, C<$E<233>> seguido por la palabra suelta C<"tat">, de la cual esta combinación resulta un error de sintaxis.

=item 6.

Esta es una combinación de las dos formas anteriores.  Solo es válido cuando no está activado S<C<"use utf8">> (se aplican las reglas normales de los identificadores cuando se está bajo S<C<"use utf8">>).  La forma es un sigil, seguido por texto entre llaves, donde el primer carácter es uno cualquiera de los caracteres en el rango C<[\x80-\xFF]> seguido por caracteres ASCII que formen parte de una palabra, hasta la llave final.

Se aplican las mismas advertencias que en la forma anterior: están obsoletos los caracteres no gráficos, no se aconseja esta forma de todas maneras, y el uso de utf8 marca una gran diferencia.

=back

Antes de Perl v5.24, también se permitían caracteres ASCII de control no gráficos en algunas situaciones; esto queda obsoleto desde v5.20.

=head2 Contexto
X<context> X<scalar context> X<list context> X<contexto> X<contexto de escalar> X<contexto de lista>

La interpretación de las operaciones y los valores en Perl depende a veces de las necesidades del contexto en el que se encuentra la operación o el valor.
Hay dos tipos principales de contexto: lista y escalar.  Algunas operaciones devuelven una lista de valores en contextos que esperan una lista, y un valor escalar en caso contrario.  Si esto es así para una operación determinada, se indicará en la documentación correspondiente a esa operación.  Es decir, Perl sobrecarga ciertas operaciones basándose en si el valor de retorno esperado es singular o plural.  Existen algunas palabras en español que funcionan de esa manera, como "crisis", "ciempiés" o "lunes", que se usan como singular o plural en función del contexto.

De forma recíproca, cualquier operación establece un contexto de escalar o un contexto de lista para cada uno de sus argumentos.  Por ejemplo, si escribe

    int( <STDIN> )

la operación int establece un contexto de escalar para el operador <>, que responde leyendo una sola línea de STDIN y pasándosela a la operación int, que a su vez calcula el valor entero de esa línea y lo devuelve.  Por otra parte, si escribe

    sort( <STDIN> )

entonces la operación sort establece un contexto de lista para <>, el cual procede a leer todas las líneas disponibles hasta alcanzar el final del archivo, y pasa esa lista de líneas a la subrutina sort, que ordena las líneas y las devuelve como una lista al contexto en que se use sort.

La asignación es un poco especial en el sentido de que utiliza el argumento de la izquierda para determinar el contexto del argumento de la derecha.  La asignación a un escalar evalúa lo que hay en el lado derecho en contexto de escalar, mientras que la asignación a un array o a un hash evalúa el lado derecho en contexto de lista.  La asignación a una lista (o a una porción, que también es una lista después de todo) también evalúa el lado derecho en contexto de lista.

Si se utiliza el pragma C<use warnings> o la opción de línea de comandos B<-w>, pueden aparecer advertencias sobre el uso inútil de constantes o funciones en contexto vacío ("I<void>").
El contexto vacío significa simplemente que se ha descartado el valor, como por ejemplo en una instrucción que consista únicamente en una cadena (p. ej., C<"alfredo";>) o una llamada a función (p. ej., C<getpwuid(0);>).  Cuenta como contexto de escalar para las funciones a las que les interesa saber si han sido llamadas en contexto de lista o no.

Para las subrutinas definidas por el usuario existe la opción de considerar si la llamada se realiza en contexto vacío, escalar o de lista.  Sin embargo, no es necesario para la mayoría de las subrutinas.  Esto se debe a que ambos tipos, escalares y listas, se interpolan automáticamente en listas.  Para saber cómo se puede averiguar dinámicamente el contexto de llamada de una función, vea la sección sobre C<wantarray> de L<perlfunc>.

=head2 Valores escalares
X<scalar> X<number> X<string> X<reference> X<escalar> X<número> X<cadena> X<referencia>

En Perl, todos los elementos de datos son escalares, arrays de escalares o hashes de escalares.  Un escalar puede contener un único valor perteneciente a uno de tres tipos posibles: número, cadena o referencia.  En general, la conversión de un tipo a otro es transparente.  Aunque un escalar no puede contener directamente múltiples valores, podría contener una referencia a un array o un hash, que sí pueden contener múltiples valores.

Los escalares no tienen que ser necesariamente una cosa u otra.  No hay ninguna forma de declarar que una variable escalar sea de tipo "cadena", "número", "referencia" o cualquier otra cosa.  Como la conversión de escalares es automática, las operaciones que los devuelven no necesitan tener en cuenta (y, de hecho, no pueden hacerlo) si el autor de la llamada espera una cadena, un número o una referencia.  Perl es un lenguaje contextualmente polimórfico, cuyos escalares pueden ser cadenas, números o referencias (entre las que se incluyen los objetos).  Aunque las cadenas y los números se consideran prácticamente la misma cosa para la mayoría de los propósitos, las referencias son punteros no convertibles y fuertemente tipados, que llevan un contador de referencias incorporado y una invocación al destructor.

Un valor escalar se interpreta como FALSO, en el sentido booleano, si está indefinido, es la cadena nula o el número 0 (o su cadena equivalente, "0"), y como VERDADERO si es cualquier otra cosa.  El contexto booleano es simplemente un tipo especial de contexto de escalar para el cual no se realiza ninguna conversión a cadena o a número.
X<boolean> X<bool> X<true> X<false> X<truth> X<booleano> X<verdadero> X<falso> X<verdad>

En realidad hay dos variantes de cadena nula (a las que algunas veces llamamos cadenas "vacías"): una definida y otra indefinida.  La versión definida es solo una cadena de longitud cero, como C<"">.
La versión indefinida es el valor que indica que no existe ningún valor real para algo, como cuando se produce un error, se alcanza el final de un archivo, o cuando se hace referencia a una variable o un elemento de array o hash no inicializados.  Aunque en las versiones anteriores de Perl un escalar no definido podía llegar a ser definido la primera vez que se usaba en cualquier lugar que esperase un valor definido, esto ya no es así, salvo en los raros casos de "autovivificación" que se describen en L<perlref>.  Se puede usar el operador defined() para determinar si un valor escalar está definido (no tiene sentido aplicar esto a arrays o hashes), y el operador undef() para producir un valor no definido.
X<defined> X<definido> X<undefined> X<indefinido> X<undef> X<null> X<nulo> X<string, null> X<cadena, nulo>

Para averiguar si una cadena determinada es un número válido distinto de cero, a veces basta con compararla con el 0 numérico y también con el "0" léxico (aunque esto provocará ruido si las advertencias están activadas).  La razón de esto es que las cadenas que no son números cuentan como 0, igual que en B<awk>:

    if ($str == 0 && $str ne "0")  {
	warn "Esto no parece un número";
    }

Este método puede ser mejor, ya que de otro modo no se pueden tratar notaciones IEEE como C<Nan> o C<Infinity>.  En otros casos, es posible que sea preferible determinar si se puede usar una cadena de datos numéricamente llamando a la función POSIX::strtod() o inspeccionando la cadena con una expresión regular (como se explica en L<perlre>).

    warn "contiene caracteres que no son dígitos" if /\D/;
    warn "no es número natural" unless /^\d+$/;             # rechaza -3
    warn "no es un entero"      unless /^-?\d+$/;           # rechaza +3
    warn "no es un entero"      unless /^[+-]?\d+$/;
    warn "no es número decimal" unless /^-?\d+\.?\d*$/;     # rechaza .2
    warn "no es número decimal" unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;
    warn "no es flotante en C"
	unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

El número de elementos (que llamaremos "longitud") de un array es un valor escalar.  Para conocer la longitud del array @jornadas, puede evaluar C<$#jornadas>, como en B<csh>.  Sin embargo, esto no es el número de elementos del array, sino el subíndice del último elemento, que es un valor distinto, ya que normalmente hay un elemento número 0.
Asignar un valor a C<$#jornadas> cambia la longitud del array.
Acortar un array de esta forma destruye los valores involucrados.  Alargar un array que ha sido acortado previamente no permite recuperar los valores que había en esos elementos
X<$#> X<array, length> X<array, longitud>

También se puede obtener un pequeño aumento de eficiencia ampliando previamente un array que va a crecer.  Otra forma de ampliar un array es hacer una asignación a un elemento que esté más allá del final del array.  Para truncar un array y dejarlo vacío, puede asignarle la lista nula ().  Las instrucciones siguientes son equivalentes:

    @algo = ();
    $#algo = -1;

Si se evalúa un array en contexto de escalar, el valor devuelto es la longitud del array  (tenga en cuenta que esto no es cierto para las listas, que devuelven el último valor, como el operador coma de C; tampoco es cierto para las funciones predefinidas, que devuelven lo que les parezca mejor devolver).  La siguiente expresión siempre es verdadera:

X<array, length> X<array, longitud>

    scalar(@algo) == $#algo + 1;

Algunos programadores eligen usar una conversión explícita para que no haya ninguna duda:

    $contador_elementos = scalar(@algo);

Si se evalúa un hash en contexto de escalar, devuelve falso si el hash está vacío.  Si contiene algún par clave/valor, devuelve verdadero; dicho con mayor exactitud, el valor devuelto es una cadena que consiste en el número de casillas utilizadas y el número de casillas asignadas, separados por una barra diagonal.  Esto solo es útil para averiguar si el algoritmo interno de almacenamiento en hash de Perl está teniendo un bajo rendimiento para un conjunto de datos.  Por ejemplo, si insertamos 10 000 valores en un hash, pero al evaluar %HASH en contexto de escalar nos devuelve C<"1/16">, significa que solo se ha ocupado una de dieciséis casillas, que probablemente contiene los 10 000 elementos.  Se supone que esto no debe de ocurrir.  Si se evalúa un hash enlazado en contexto de escalar, se llama al método C<SCALAR> (con una retrollamada a C<FIRSTKEY>).
X<hash, scalar context> X<hash, contexto de escalar> X<hash, bucket> X<hash, casilla> X<bucket> X<casillas>

Puede reservar espacio para un hash mediante una asignación a la función keys().
Esto redondea el número de casillas reservadas a la siguiente potencia de dos:

    keys(%usuarios) = 1000;		# asigna 1024 casillas

=head2 Constructores de valores escalares
X<scalar, literal> X<scalar, constant> X<escalar, literal> X<escalar, constante>

Los literales numéricos se especifican en cualquiera de los siguientes formatos de punto flotante o entero:

 12345
 12345.67
 .23E-10             # un número muy pequeño
 3.14_15_92          # un número muy importante
 4_294_967_296       # guión bajo para mejor legibilidad
 0xff                # hex
 0xdead_beef         # más hex
 0377                # octal (solo números, comienza con 0)
 0b011011            # binario
 0x1.999ap-4         # punto flotante hexadecimal (la 'p' es necesaria)

Está permitido el uso de guiones bajos (caracteres de subrayado) entre dígitos en literales numéricos para mejorar la legibilidad (pero no se permite usar varios guiones bajos seguidos: C<23__500> no es válido; C<23_500>, sí).
Por ejemplo, puede agrupar los dígitos binarios en grupos de tres (como para un argumento de modo estilo Unix, p. ej., 0b110_100_100) o de cuatro (para representar nibbles, como en 0b1010_0110), o bien en grupos de otros tamaños.
X<number, literal> X<número, literal>

Los literales de cadena se suelen delimitar con comillas simples o dobles.  Estas comillas funcionan de forma muy parecida a las comillas en las shell estándar de Unix: los literales de cadena entre comillas dobles están sujetos al uso de la barra diagonal inversa y la sustitución de variables; en cambio, las cadenas entre comillas simples no lo están (a excepción de C<\'> y C<\\>).  Se aplican las reglas normales de barra diagonal inversa estilo C para crear caracteres como el salto de línea, tabulaciones, etc., y algunas formas más exóticas.  Encontrará una lista en la sección "Comillas y operadores de comillas" de L<perlop>.
X<string, literal> X<cadena, literal>

Las representaciones hexadecimales, octales o binarias en cadenas literales (por ejemplo, '0xff') no se convierten automáticamente en su representación en enteros.  Las funciones hex() y oct() hacen estas conversiones.  Vea "hex" y "oct" en L<perlfunc> para obtener más información.

El punto flotante hexadecimal puede empezar justo como un literal hexadecimal, y puede seguirse por una parte fraccionaria hexadecimal opcional, pero debe seguirse por una C<p>, un signo opcional, y una potencia de dos.
El formato es útil para presentar de forma precisa valores de punto flotante, evitando conversiones a o desde un punto flotante decimal, y por lo tanto evitando posibles pérdidas de precisión.  Note que mientras la mayor parte de las plataformas usan punto flotante de 64 bit IEEE 754, no todas lo hacen.  Otra potencial fuente de diferencias de bajo nivel son los modos de redondeo de punto flotante, que pueden diferir entre CPU, sistemas operativos, y compiladores, que Perl no controla.

También puede incrustar directamente caracteres de nueva línea en las cadenas; es decir, las cadenas pueden terminar en una línea distinta.  Esto está bien, pero si se le olvida cerrar el entrecomillado, no se notificará el error hasta que Perl encuentre otra línea que contenga el carácter de comilla, que puede estar mucho más abajo en el programa.  La sustitución de variables dentro de cadenas se limita a variables escalares, arrays y porciones de array o hash  (es decir, los nombres que empiezan por $ o @, seguidos de una expresión opcional de subíndice entre corchetes).  El segmento de código siguiente imprime en pantalla "El precio es $100".
X<interpolation> X<interpolación>

    $precio = '$100';                 # no se interpola
    print "El precio es $precio.\n";  # se interpola

No hay doble interpolación en Perl, por lo que C<$100> queda tal como está.

De forma predeterminada, los números de punto flotante sustituidos dentro de cadenas usan el punto (".") como separador decimal.  Si C<use locale> está activo y se llama a POSIX::setlocale(), la configuración regional LC_NUMERIC determina el carácter que se utiliza como separador decimal.
Vea L<perllocale> y L<POSIX>.

Al igual que en algunos entornos de líneas de comandos, puede escribir el nombre de la variable entre llaves para eliminar la ambigüedad de los ulteriores caracteres alfanuméricos (y guiones bajos).
También debe hacer esto al interpolar una variable en una cadena para separar el nombre de una variable de un doble signo de dos puntos o un apóstrofo, a fin de evitar que se traten como separadores de paquete:
X<interpolation> X<interpolación>

    $usuario = "Larry";
    print PASSWD "${usuario}::0:0:Superuser:/:/bin/perl\n";
    print "Pasamos a hablar en el idiolecto ${usuario}nés cuando el australiano chilla '${usuario}'s coming!'.\n";

Sin las llaves, Perl buscaría las variables $usuarionés, C<$usuario::0> y C<$usuario's>.  Las dos últimas serían las variables $0 y $s del paquete C<usuario>, que probablemente no exista.

De hecho, cuando se escribe un único identificador entre llaves, se le fuerza a ser una cadena, como cualquier identificador en un subíndice de hash.  En ninguno de estos casos hay que usar comillas.  En un ejemplo anterior, C<$jornadas{'Feb'}> puede escribirse como C<$jornadas{Feb}> y las comillas se agregarán automáticamente.  Pero cualquier otra cosa más complicada en el subíndice se interpretará como una expresión.  Esto significa, por ejemplo, que C<$version{2.0}++> es equivalente a C<$version{2}++>, no a C<$version{'2.0'}++>.

=head3 Punto flotante especial: infinito (Inf) y no-es-un-número (I<not-a-number>) (NaN)

Los valores de punto flotante incluyen a los valores especiales C<Inf> y C<NaN>, para infinito y no-es-un-número.  Infinito también puede ser negativo.

Infinito es el resultado de ciertas operaciones matemáticas que desbordan el rango de punto flotante, como 9**9**9.  El no-es-un-número es el resultado cuando el resultado es indefinido o no representable.  Aunque debe notar que no puede obtener un C<NaN> de algunas operaciones "indefinidas" o "fuera-de-rango", comunes, como división por cero, o la raíz cuadrada de un número negativo, ya que Perl genera un error fatal para estas.

Infinito y no-es-un-número tienen sus propias reglas aritméticas especiales.
La regla general es que son "contagiosas": C<Inf> más uno es C<Inf>, y C<NaN> más uno es C<NaN>.  Donde las cosas se vuelven interesantes es cuando combinamos infinitos y no-es-un-número: C<Inf> menos C<Inf>; e C<Inf> dividido por C<INf> es C<NaN> (mientras C<Inf> más C<Inf> es C<Inf>; e C<Inf> multiplicado por C<Inf> es C<Inf>).  C<NaN> es también curioso, en el sentido de que no es igual a ningún número, I<incluido> él mismo: C<NaN> != C<NaN>.

Perl no entiende C<Inf> y C<NaN> como literales numéricos, pero puede tratarlos como cadenas, y Perl los convertirá si es necesario: "Inf" + 1.  (Puede, sin embargo, importarlos desde la extensión POSIX; C<use POSIX qw(Inf NaN);> y usarlos como literales).

Note que en la entrada (cadena a número) Perl acepta C<Inf> y C<NaN> de varias formas.   El tamaño de caja se ignora, y las formas específicas de Win32 como C<1.#INF> son aceptadas, pero a la salida los valores se normalizan a C<Inf> y C<NaN>.

=head3 Cadenas de versión
X<version string> X<vstring> X<v-string> X<cadena de versión>

Un literal de la forma C<v1.20.300.4000> se analiza como una cadena compuesta de caracteres con los valores ordinales especificados.  Esta forma, conocida como "v-string", ofrece una alternativa para crear cadenas más legible que una forma de interpolación como C<"\x{1}\x{14}\x{12c}\x{fa0}">.  Esto es útil para la representación de cadenas Unicode, y para comparar los "números" de versión que utilizan los operadores de comparación de cadenas, C<cmp>, C<gt>, C<lt>, etc. Si hay dos o más puntos en el literal, se puede omitir el prefijo C<v>.

    print v9786;              # imprime en pantalla un emoticono, "\x{263a}"
    print v102.111.111;       # imprime en pantalla "foo"
    print 102.111.111;        # lo mismo

C<require> y C<use> aceptan estos literales para realizar una comprobación de versión.  Tenga en cuenta que el uso de v-strings para las direcciones IPv4 no es portable a menos que también utilice las rutinas inet_aton()/inet_ntoa() del paquete Socket.

También debe tener en cuenta que, desde la versión Perl 5.8.1, las cadenas v-string de un solo número (como C<v65>) no son v-strings delante del operador C<< => >> (que se utiliza normalmente para separar una clave hash de un valor hash), sino que se interpretan como cadenas literales ('v65').  Fueron v-strings desde Perl 5.6.0 a Perl 5.8.0, pero su uso causaba confusión y problemas.
Las v-strings con varios números, como C<v65.66> y C<65.66.67>, siguen siendo v-strings.

=head3 Literales especiales
X<special literal> X<__END__> X<__DATA__> X<END> X<DATA>
X<end> X<data> X<^D> X<^Z> X<literal especial>

Los literales especiales __FILE__, __LINE__ y __PACKAGE__ representan el nombre del archivo, el número de línea y el nombre del paquete actuales en ese punto del programa.  __SUB__ devuelve una referencia a la subrutina actual.  Solo se pueden utilizar como símbolos aislados; no se interpolan dentro de cadenas.  Si no hay ningún paquete actual (debido a una directiva C<package;> vacía), __PACKAGE__ tiene el valor indefinido  (aunque desde la versión 5.10 se dejó de admitir la directiva C<package;> vacía).  Fuera de una subrutina, __SUB__ devuelve el valor indefinido.  __SUB__ solo está disponible en la versión 5.16 o superior, y solo con un C<use v5.16> o una declaración C<use feature "current_sub">.
X<__FILE__> X<__LINE__> X<__PACKAGE__> X<__SUB__>
X<line> X<file> X<package> X<línea> X<archivo> X<paquete>

Se pueden usar los dos caracteres de control ^D y ^Z, y los símbolos __END__ y __DATA__, para indicar el final lógico del programa antes del final real del archivo.  Se omitirá el texto que haya a continuación.

El texto que hay a continuación de __DATA__ se puede leer mediante el identificador de archivo C<PAQUETE::DATA>, donde C<PAQUETE> es el paquete que estaba activo cuando se encontró el símbolo __DATA__.  El identificador de archivo se deja abierto apuntando a la línea que hay a continuación de __DATA__.  El programa debe ejecutar C<close DATA> cuando termine de leer.  (Si se deja abierto el identificador de archivo, provoca una pérdida de identificadores de archivos en caso de que se vuelva a cargar el módulo por alguna razón, así que es recomendable cerrarlo).  Por compatibilidad con I<scripts> antiguos, escritos antes de la introducción de __DATA__, __END__ se comporta como __DATA__ en el I<script> de nivel superior (pero no en los archivos cargados con C<require> o C<do>) y deja el resto del contenido del archivo accesible a través de C<main::DATA>.

Encontrará una descripción más detallada y ejemplos de uso de __DATA__ en L<SelfLoader>.  Tenga en cuenta que no puede leer el identificador de archivo DATA en un bloque BEGIN: el bloque BEGIN se ejecutará tan pronto como se encuentre (durante la compilación), momento en que aún no se ha visto el símbolo __DATA__ (o __END__) correspondiente.

=head3 Palabras sueltas
X<palabra suelta>

Una palabra que no tiene ninguna interpretación en la gramática se tratará como si fuera una cadena entrecomillada.  En Perl, estas palabras se denominan "I<barewords>" (palabras sueltas).  Al igual que con los identificadores de archivo y las etiquetas, una palabra suelta formada por un conjunto de letras minúsculas supone un riesgo de conflicto con futuras palabras reservadas, por lo que si se usa el pragma C<use warnings> o la opción B<-w>, Perl mostrará una advertencia.  Perl limita la longitud de las palabras sueltas a cerca de 250 caracteres (igual que los identificadores).  Es probable que estas limitaciones arbitrarias se eliminen en futuras versiones de Perl.

Es posible que algunos programadores prefieran prohibir el uso de palabras sueltas.  Si escribe

    use strict 'subs';

cualquier palabra suelta que NO se pueda interpretar como una llamada de subrutina, generará un error en tiempo de compilación.  La restricción dura hasta el final del bloque en que se encuentre.  En un bloque interno se puede revocar esto mediante C<no strict 'subs'>.

=head3 Interpolación de arrays
X<array, interpolation> X<interpolation, array> X<$"> X<array, interpolación> X<interpolación, array>

Dentro de cadenas escritas entre comillas dobles, los arrays y las porciones se interpolan uniendo los elementos con el delimitador especificado en la variable C<$"> (C<$LIST_SEPARATOR> si se especifica "use English;"); el valor predeterminado es un espacio en blanco.  Las instrucciones siguientes son equivalentes:

    $temporal = join($", @ARGV);
    system "echo $temporal";

    system "echo @ARGV";

Dentro de los patrones de búsqueda (donde también se realiza la sustitución del entrecomillado doble) existe una desafortunada ambigüedad: ¿Debe C</$foo[bar]/> ser interpretado como C</${foo}[bar]/> (donde C<[bar]> es una clase de caracteres para la expresión regular) o como C</${foo[bar]}/> (donde C<[bar]> es el subíndice del array @foo)?  Si @foo no existe, entonces es evidente que se trata de una clase de caracteres.  Si @foo existe, Perl tiene una buena pista acerca de C<[bar]>, y casi siempre acierta.  Por si se equivoca, o para evitar ataques de paranoia, puede forzar la interpretación correcta con llaves, como se indicó arriba.

Si busca información acerca de cómo usar documentos incrustados, que solía estar en este documento, debe saber que ahora se encuentra en la sección "Comillas y operadores de comillas" de L<perlop>.

=head2 Constructores de listas
X<list> X<lista>

Una lista se especifica escribiendo los valores individuales separados por comas (si la precedencia lo requiere, la lista debe escribirse entre paréntesis):

    (LISTA)

En un contexto que no requiera una lista, el valor de lo que parece ser un literal de lista es simplemente el valor del último elemento, igual que con el operador coma en C.  Por ejemplo,

    @foo = ('cc', '-E', $bar);

asigna la lista completa al array @foo, pero

    $foo = ('cc', '-E', $bar);

asigna el valor de la variable $bar a la variable escalar $foo.
Tenga en cuenta que el valor de un array en contexto de escalar es la longitud del array; la línea siguiente asigna el valor 3 a $foo:

    @foo = ('cc', '-E', $bar);
    $foo = @foo;                # se asigna 3 a $foo

Opcionalmente, puede agregar una coma antes del paréntesis de cierre en una lista literal, de modo que puede escribir:

    @foo = (
        1,
        2,
        3,
    );

Para usar un documento incrustado con el fin de asignar un array (una línea por elemento), puede hacer esto:

    @salsas = <<Fin =~ m/(\S.*\S)/g;
        tomate normal
        tomate especiado
        chile verde
        pesto
        vino blanco
    Fin

En una LISTA se interpolan automáticamente las sublistas.  Es decir, cuando se evalúa una LISTA, cada uno de sus elementos se evalúa en contexto de lista, y el valor de lista resultante se interpola en LISTA como si cada elemento individual fuera un miembro de LISTA.  Así, los arrays y hashes pierden su identidad en una LISTA: la lista

    (@foo,@bar,&AlgunaSub,%glarch)

contiene todos los elementos de @foo, seguidos de todos los elementos de @bar, seguidos de todos los elementos devueltos por la subrutina AlgunaSub llamada en contexto de lista, seguidos de los pares clave/valor de %glarch.
Para crear una referencia de lista que I<NO> se interpole, vea L<perlref>.

La lista nula se representa por ().  Interpolarla en una lista no surte ningún efecto.  Así que ((),(),()) es equivalente a ().  Del mismo modo, interpolar un array sin elementos produce el mismo resultado que no interpolar ningún array.

Esta interpolación combinada con el hecho de que los paréntesis de apertura y cierre son opcionales (salvo cuando sea necesario por razones de precedencia) y que las listas pueden terminar con una coma opcional, indica que el uso de comas múltiples dentro de las listas es sintaxis válida.  La lista C<1,,3> es una concatenación de dos listas, C<1,> y C<3>, la primera de las cuales termina con una coma opcional.  C<1,,3> es C<(1,),(3)> y C<1,3> (y, de manera similar, C<1,,,3> es C<(1,),(,),3> y C<1,3>, y así sucesivamente).  Le recomendamos que no use este tipo de ofuscación.

Una lista de valores también se puede indexar como un array normal.  Debe escribir la lista entre paréntesis para evitar ambigüedades.  Por ejemplo:

    # stat devuelve una lista.
    $time = (stat($archivo))[8];

    # ERROR DE SINTAXIS.
    $acceso = stat($archivo)[8];  # VAYA, OLVIDÓ LOS PARÉNTESIS

    # Buscar un dígito hexadecimal.
    $digitohex = ('a','b','c','d','e','f')[$digito-10];

    # Un "operador coma inverso".
    return (pop(@foo),pop(@foo))[0];

Solo se puede asignar a una lista si cada elemento de la lista permite la asignación:

    ($a, $b, $c) = (1, 2, 3);

    ($mapa{'rojo'}, $mapa{'azul'}, $mapa{'verde'}) = (0x00f, 0x0f0, 0xf00);

Una excepción a esto es que se puede asignar a C<undef> en una lista.
Esto es útil para descartar algunos de los valores devueltos por una función:

    ($dev, $ino, undef, undef, $uid, $gid) = stat($archivo);

A partir de Perl 5.22, puede usar también C<(undef)x2> en lugar de C<undef, undef>.
(Puede también hacer C<($x) x 2>, que es menos útil, porque asigna a la misma variable dos veces, sobreescribiendo el primer valor asignado).

La asignación de una lista en contexto de escalar devuelve el número de elementos producidos por la expresión en el lado derecho de la asignación:

    $x = (($foo,$bar) = (3,2,1));       # asigna 3 a $x, no 2
    $x = (($foo,$bar) = f());           # asigna a $x el número de valores devueltos por f()

Esto es útil cuando se quiere hacer una asignación de lista en un contexto booleano, ya que la mayoría de funciones de lista, al terminar de ejecutarse devuelven una lista nula que, al asignarse, produce un 0, lo que se interpreta como FALSO.

Es también el origen de un modismo muy útil para ejecutar una función o realizar una operación en contexto de lista, y luego contar el número de valores devueltos, mediante la asignación a una lista vacía y el uso posterior de esa asignación en contexto de escalar.  Por ejemplo, este código:

    $recuento = () = $cadena =~ /\d+/g;

pondrá en $recuento el número de grupos de dígitos que se encuentren en $cadena.
Esto sucede porque la expresión regular está en contexto de lista (ya que se asigna a la lista vacía) y, por lo tanto, se obtendrá una lista de todas las coincidencias encontradas en la cadena.  La asignación de lista en contexto de escalar se traducirá en el número de elementos (en este caso, el número de veces que se detecta el patrón), que se asignará a $recuento.  Tenga en cuenta que el simple uso de

    $recuento = $cadena =~ /\d+/g;

no habría funcionado, ya que la detección de patrones mediante una expresión regular en contexto de escalar sólo devolverá verdadero o falso, en lugar de un recuento de coincidencias detectadas.

El último elemento de una asignación de lista puede ser un array o un hash:

    ($a, $b, @resto) = split;
    my($a, $b, %resto) = @_;

En realidad, se puede colocar un array o un hash en cualquier lugar de la lista, pero el primero que figure en la lista absorberá todos los valores, y lo que venga después quedará indefinido.  Esto puede ser útil para my() o local().

Un hash se puede inicializar con una lista literal que contenga pares de elementos que deben interpretarse como pares clave/valor:

    # la misma asignación de antes
    %mapa = ('rojo',0x00f,'azul',0x0f0,'verde',0xf00);

Aunque las listas literales y los arrays con nombre suelen ser intercambiables, no ocurre así con los hashes.  Solo porque se pueda indexar una lista de valores como un array normal no significa que se pueda indexar una lista de valores como un hash.  Del mismo modo, los hashes incluidos como parte de otras listas (incluidas las listas de parámetros y las listas de retorno de funciones) siempre se extienden en pares clave/valor.  Es por eso que, en algunas situaciones, es recomendable utilizar referencias.

El operador C<< => >> entre los pares clave/valor suele mejorar la legibilidad.  Este operador es más que nada un distintivo visual sinónimo de una coma, pero también se encarga de que el operando de la izquierda se interprete como una cadena, si es una palabra suelta que se pudiera considerar como un identificador simple válido.  C<< => >> no entrecomilla identificadores compuestos que contengan signos de dos puntos dobles.  Este operador es cómodo para inicializar un hash:

    %map = (
                 red   => 0x00f,
                 blue  => 0x0f0,
                 green => 0xf00,
   );

o para inicializar referencias de hash que se usarán como registros:

    $rec = {
                bruja => 'La implacable Piruja',
                gato  => 'Fofito Feroz',
                fecha => '10/31/1776',
    };

o para utilizar llamadas mediante parámetros con nombre para funciones complicadas:

   $campo = $query->radio_group(
               name      => 'nombre_grupo',
               valores   => ['eenie','meenie','minie'],
               default   => 'meenie',
               linebreak => 'true',
               labels    => \%etiquetas
   );

Tenga en cuenta que aunque un hash se inicialice en ese orden, sus valores no tienen por qué salir en el mismo orden.  En la sección "sort" de L<perlfunc> encontrará ejemplos de cómo generar una salida ordenada.

Si una clave aparece más de una vez en la lista inicial de un hash, gana la última ocurrencia:

    %circulo = (
                  centro => [5, 10],
                  centro => [27, 9],
                  radio  => 100,
                  color  => [0xDF, 0xFF, 0x00],
                  radio  => 54,
    );

    # es lo mismo que
    %circulo = (
                  centro => [27, 9],
                  color  => [0xDF, 0xFF, 0x00],
                  radio  => 54,
    );

Esto se puede usar para ofrecer la característica de sobreescribir los valores por defecto, en una configuración:

    # valores en %argumentos tiene prioridad sobre %configuracion_por_defecto
    %configuracion = (%configuracion_por_defecto, %argumentos);

=head2 Subíndices

Se puede acceder a un array de escalar en escalar, especificando un signo dólar (C<$>) seguido del nombre del array (sin el signo C<@> inicial) y el subíndice entre corchetes.  Por ejemplo:

    @miarray = (5, 50, 500, 5000);
    print "El tercer elemento es", $miarray[2], "\n";

Los índices de array empiezan por 0.  Un subíndice negativo devuelve un valor contando desde el final.  En nuestro ejemplo, C<$miarray[-1]> es 5000 y C<$miarray[-2]> es 500.

Los índices en los hashes son similares, pero en lugar de corchetes se usan llaves.  Por ejemplo:

    %cientificos = 
    (
        "Newton"  => "Isaac",
        "Einstein"=> "Albert",
        "Darwin"  => "Charles",
        "Feynman" => "Richard",
    );

    print "El nombre de Darwin es", $cientificos{"Darwin"}, "\n";

También puede subindexar una lista para obtener un solo elemento de ella.

    $dir = (getpwnam("daemon"))[7];

=head2 Emulación de matrices multidimensionales

Puede emular matrices multidimensionales utilizando listas como subíndices de un hash.  Los elementos de la lista se unen con el separador de subíndice (vea "$;" en L<perlvar>).

    $foo{$a,$b,$c}

es equivalente a

    $foo{join($;, $a, $b, $c)}

El separador de subíndice predeterminado es "\034", el mismo que SUBSEP en B<awk>.

=head2 Porciones
X<slice> X<array, slice> X<hash, slice> X<porción> X<array, porción> X<hash, porción>

Una porción permite acceder de forma simultánea a varios elementos de una lista, un array o un hash, mediante una lista de subíndices.  Esto es más cómodo que escribir los elementos individuales como una lista de valores escalares.

    ($el, $ella)        = @gente[0,-1];              # porción de array
    @ellos              = @gente[0 .. 3];            # porción de array
    ($usuario, $inicio) = @ENV{"USER", "HOME"};      # porción de hash
    ($uid, $dir)        = (getpwnam("daemon"))[2,7]; # porción de lista

Como podemos asignar a una lista de variables, también podemos a una porción de array o de hash.

    @jornadas[3..5] = qw/Mié Jue Vie/;
    @colores{'rojo','azul','verde'} 
                   = (0xff0000, 0x0000ff, 0x00ff00);
    @gente[0, -1]   = @gente[-1, 0];

Las asignaciones anteriores equivalen exactamente a

    ($jornadas[3], $jornadas[4], $jornadas[5]) = qw/Mié Jue Vie/;
    ($colores{'rojo'}, $colores{'azul'}, $colores{'verde'})
                   = (0xff0000, 0x0000ff, 0x00ff00);
    ($gente[0], $gente[-1]) = ($gente[-1], $gente[0]);

Como al modificar una porción se modifica el array o hash original, una construcción C<foreach> modificará algunos (o incluso todos) los valores del array o hash.

    foreach (@array[ 4 .. 10 ]) { s/pedro/pablo/ } 

    foreach (@hash{qw[clave1 clave2]}) {
        s/^\s+//;           # quitar espacios iniciales
        s/\s+$//;           # quitar espacios finales
        s/(\w+)/\u\L$1/g;   # escribir letras iniciales en mayúsculas
    }

Como excepción especial, cuando se parte una lista (pero no un array o un hash), si la lista se evalúa a vacía, entonces tomar una parte de una lista vacía siempre devolverá una lista vacía.  Por lo tanto:

    @a = ()[0,1];          # @a no tiene elementos
    @b = (@a)[0,1];        # @b no tiene elementos
    @c = (sub{}->())[0,1]; # @c no tiene elementos
    @d = ('a','b')[0,1];   # @d tiene dos elementos
    @e = (@d)[0,1,8,9];    # @e tiene cuatro elementos
    @f = (@d)[8,9];        # @f tiene dos elementos

Esto facilita la escritura de bucles que terminan cuando se devuelve una lista vacía:

    while ( ($inicio, $usuario) = (getpwent)[7,0] ) {
        printf "%-8s %s\n", $usuario, $inicio;
    }

Como se ha señalado anteriormente en este documento, el sentido escalar de una asignación de lista es el número de elementos en el lado derecho de la asignación.
La lista vacía no contiene elementos, así que cuando se acaba el archivo de contraseñas, el resultado es 0, no 2.

En contexto de escalar, las porciones devuelven el último elemento de la porción.

    @a = qw/primero segundo tercero/;
    %h = (primero => 'A', segundo => 'B');
    $t = @a[0, 1];                     # Ahora $t es 'segundo'
    $u = @h{'primero', 'segundo'};     # Ahora $u es 'B'

Si se está preguntando por qué se usa un signo '@' en una porción de hash en lugar de un signo '%', piense en esto:  el tipo de delimitador (corchete o llave) indica si se trata de un array o un hash.
Por otra parte, el símbolo inicial ('$' o '@') del nombre del array o hash indica si se va a obtener un solo valor (un escalar) o varios (una lista).

=head3 Porciones hash clave/valor

A partir de Perl 5.20, una operación de partición hash con el símbolo %, es una variante de operación de partición que devuelve una lista de pares clave/valor en lugar de sólo los valores:

    %h = (blonk => 2, foo => 3, squink => 5, bar => 8);
    %subconjunto = %h{'foo', 'bar'}; # porción hash clave/valor
    # %subconjunto ahora es (foo => 3, bar => 8)

Sin embargo, el resultado de tal partición no puede ser localizado, eliminado o utilizado en una asignación.  En cambio, ahora son mucho más consistentes con las particiones hash que usan el símbolo @.

=head3 Porciones array índice/valor

De manera similar a las particiones hash clave/valor (y también introducidas en Perl 5.20), la sintaxis de partición de array regresa una lista de pares índice/valor:

    @a = "a".."z";
    @lista = %a[3,4,6];
    # @lista ahora es (3, "d", 4, "e", 6, "g")

=head2 Typeglobs e identificadores de archivo
X<typeglob> X<filehandle> X<*> X<identificador de archivo>

Perl utiliza un tipo interno denominado I<typeglob> para mantener una entrada completa en la tabla de símbolos.  El prefijo de tipo de un typeglob es C<*>, ya que representa todos los tipos.  En el pasado, esta era la forma preferida de pasar arrays y hashes por referencia a una función, pero como ahora tenemos referencias de verdad, ya no se suele usar un typeglob para este fin.  

El uso principal de los typeglobs en Perl moderno es crear alias en la tabla de símbolos.
La siguiente asignación:

    *este = *ese;

hace que $este sea un alias de $ese, @este sea un alias de @ese, %este sea un alias de %ese, etc. Es mucho más seguro usar una referencia.
La línea siguiente:

    local *este::azul = \$ese::verde;

hace que $este::azul sea temporalmente un alias de $ese::verde, pero no hace que @este::azul sea un alias de @ese::verde, o que %este::azul sea un alias de %ese::verde, etc. Encontrará más ejemplos en la sección "Tablas de símbolos" de L<perlmod>.  Por extraño que pueda parecer, esta es la base de todo el sistema de importación/exportación de módulos.

Otro uso de los typeglobs es pasar identificadores de archivo a una función o crear nuevos identificadores de archivo.  Si tiene que usar un typeglob para guardar un identificador de archivo, hágalo de esta manera:

    $id_archivo = *STDOUT;

o tal vez como una referencia real, de esta manera:

    $id_archivo = \*STDOUT;

En L<perlsub> encontrará más ejemplos de uso de typeglobs como identificadores de archivos indirectos en funciones.

Los typeglobs también proporcionan una manera de crear un identificador de archivo local con el operador local().  Durará hasta que se salga del bloque, pero se puede volver a pasar.
Por ejemplo:

    sub nuevoopen {
        my $ruta = shift;
        local  *ARCHIVO;  # en lugar de "my"
        open   (ARCHIVO, $ruta)          or  return undef;
        return *ARCHIVO;
    }
    $id_archivo = nuevoopen('/etc/passwd');

Ahora que tenemos la notación C<*foo{COSA}> ya no se usan tanto los typeglobs para la manipulación de identificadores de archivo, aunque siguen siendo necesarios para pasar identificadores de archivo y de directorio a (o desde) funciones.  Esto se debe a que C<*IDENTIFICADOR{IO}> solo funciona si ya se ha utilizado IDENTIFICADOR como un identificador.
Es decir, se debe usar C<*ARCHIVO> para crear nuevas entradas en la tabla de símbolos; no se puede hacer con C<*foo{COSA}>.  En caso de duda, use C<*ARCHIVO>.

Todas las funciones capaces de crear identificadores de archivo (open(), opendir(), pipe(), socketpair(), sysopen(), socket() y accept()) crean automáticamente un identificador de archivo anónimo si el identificador que se les pasa es una variable escalar sin inicializar.  Esto permite utilizar instrucciones como C<open(my $archivo, ...)> y C<open(local $archivo,...)> para crear identificadores de archivo que convenientemente se cerrarán automáticamente cuando termine el ámbito de aplicación, siempre que no haya otras referencias a ellos.  Esto elimina en gran medida la necesidad de usar typeglobs al abrir identificadores de archivo que hay que pasar de un lugar a otro, como en el ejemplo siguiente:

    sub miopen {
        open my $fh, "@_"
             or die "No puedo abrir '@_': $!";
        return $archivo;
    }

    {
        my $f = miopen("</etc/motd");
        print <$f>;
        # $f se cierra aquí implícitamente
    }

Tenga en cuenta que si se usa una variable escalar ya inicializada, el resultado es diferente: C<my $archivo='zzz'; open($archivo, ...)> es equivalente a C<open( *{'zzz'}, ...)>.
C<use strict 'refs'> prohíbe hacer esto.

Otra forma de crear identificadores de archivo anónimos es usar el módulo Symbol o IO::Handle y sus acólitos.  Estos módulos tienen la ventaja de no ocultar diferentes tipos del mismo nombre mientras local() esté activo.  Encontrará un ejemplo al final de la sección "open" de L<perlfunc>.

=head1 VEA TAMBIÉN

En L<perlvar> verá una descripción de las variables predefinidas de Perl y de las normas de nomenclatura de variables.  Para obtener más información sobre los typeglobs y la sintaxis de C<*foo{COSA}>, vea L<perlref>, L<perlsub> y "Tablas de símbolos" en L<perlmod>.
