=head1 NOMBRE

perlunicode - Soporte Unicode en Perl

=head1 DESCRIPCIÓN

Si no lo ha hecho antes, antes de leer este documento, debería familiarizarse con L<perlunitut> y L<perluniintro>.

La intención de Unicode es B<UNI>-ficar los diferentes B<CODE> (B<CÓDIGO>-s) de todos los conjuntos de caracteres en un único estándar.   Para bastantes de los estándares de codificación que existieron cuando se creó Unicode, convertir cada uno de ellos a Unicode significaba, esencialmente, añadir una constante a cada punto de código del estándar original, y reconvertirlo simplemente quitando la misma constante.  Para ASCII e ISO-8859-1, la constante es 0.  Para ISO-8859-5, (Cirílico) la constante es 864; para el Hebreo (ISO-8859-8), es 1488; Thai (ISO-8859-11), 3424; y así.  Esto hizo fácil las conversiones, y facilitó la adopción de Unicode.

Y funcionaba; hoy en día, estos estándares heredados raramente se usan.  Casi todo el mundo usa Unicode.

Unicode es un estándar global.  Especifica muchas cosas que están fuera del ámbito de Perl, como la forma de mostrar secuencias de caracteres.  Para una explicación completa de todos los aspectos de Unicode, vea L<http://www.unicode.org>

=head2 Problemas importantes

Incluso aunque algo de esta sección no sea del todo entendible por usted, en una primera lectura, pensamos que es bastante importante destacar algunas trampas antes de cavar más allá, así que, allá vamos:

El soporte Unicode es un requerimiento extensivo. Mientras que Perl no implementa el estándar Unicode o los informes técnicos anexos, de cabo a rabo, Perl soporta muchas características de Unicode.

También, el uso de Unicode puede presentar problemas de seguridad que no son obvios.
Lea L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.

=over 4

=item Más seguro si usa C<use feature 'unicode_strings'>

En orden de preservar la retrocompatibilidad, Perl no da un soporte Unicode interno completo a menos que se especifique el I<pragma> L<S<C<use feature 'unicode_strings'>>|feature/La característica 'unicode_strings'>.  (Esto es lo que se selecciona automáticamente si usa S<C<use 5.012>> o superior).  Fallar en esto puede provocar sorpresas inesperadas.  Vea L</El "Error de Unicode">, más abajo.

Este pragma no afecta a la E/S.  No cambia la representación interna de las cadenas, solo su interpretación.  Existen todavía diversos lugares dodne Unicode no se soporta completamente, como el caso de los nombres de los archivos.

=item Capas de Entrada y Salida

Use la capa C<:encoding(...)> para leer de y escribir hacia identificadores de archivos que usen la codificación que se especifica.  (Vea L<open>).

=item Debería convertir sus I<scripts> Perl no-ASCII, no-UTF-8, a UTF-8.

Vea L<encoding>.

=item C<use utf8> se sigue necesitando para activar L<UTF-8|/Codificaciones Unicode> en los I<scripts>

Si su I<script> Perl está codificado en L<UTF-8|/Codificaciones Unicode>, el I<pragma> S<C<use utf8>> debe incluirse explícitamente para activar su reconocimiento (en los literales de cadenas y expresiones regulares, o nombres de identificadores).  B<Esta es la única ocasión en que se necesita un S<C<use utf8>> explícito>. (Vea L<utf8>).

=item Se autodetectan los I<scripts> marcados con C<BOM> y L<UTF-16|/Codificaciones Unicode>

Sin embargo, si un I<script> Perl comienza con el C<BOM> Unicode (UTF-16LE, UTF16-BE, o UTF-8), o si el I<script> parece un UTF-16 sin marca C<BOM>, de cualquier orden de bytes, Perl leerá correctamente el I<script> con la codificación Unicode apropiada.  (Un UTF-8 sin C<BOM> no se puede reconocer de forma efectiva, o diferenciar de ISO 8859-1 u otra codificación de 8 bit).

=back

=head2 Semánticas de byte y carácter

Antes de Unicode, la mayor parte de las codificaciones usaban 8 bit (un único byte) para codificar cada carácter.  Por ello, un carácter era un byte, y un byte era un carácter, y solo podrían existir 256 posibles caracteres, o menos.
"Semánticas de Byte" en el título de esta sección se refiere a este comportamiento.  No había necesidad de distinguir entre "Byte" y "Carácter".

Y luego llegó Unicode con espacio para más de un millón de caracteres (y Perl permite incluso más).  Esto significa que un carácter puede requerir más de un único byte para representarlo, y así los dos términos ya no son equivalentes.  Lo que importa son los caracteres como entidades completas, y no entenderlos como los bytes que los forman.  Esto es a lo que se refiere "Semántica de Carácter" en el título de esta sección.

Perl tiene que cambiar, internamente, para desacoplar los "bytes" de los "caracteres".
Es importante que usted también cambie sus ideas, si no lo ha hecho, así que "byte" y "carácter" ya no significa lo mismo en su cabeza.

El bloque de construcción básico de las cadenas Perl siempre ha sido un "carácter".
Los cambios, básicamente, se reducen a que la implementación ya no cree que un carácter siempre es un único byte.

Hay varias cosas que hay que anotar:

=over 4

=item *

Las funciones de manejo de cadenas, en su mayor parte, continúan operando en términos de caracteres.  C<length()>, por ejemplo, devuelve el número de caracteres en una cadena, igual que antes.  Pero el número ya no es necesariamente el mismo que el número de bytes en la cadena (podría haber más bytes que caracteres).  Otras funciones que se incluyen son C<chop()>, C<chomp()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>, C<sort()>, C<sprintf()> y C<write()>.

Las excepciones son:

=over 4

=item *

el orientado a bit C<vec>

E<nbsp>

=item *

el formato orientado a byte C<pack>/C<unpack> C<"C">

Sin embargo, el especificador C<W> opera sobre caracteres enteros, igual que el especificador C<U>.

=item *

algunos operadores que interaccionan con el sistema operativo de la plataforma

Son ejemplos los operadores que tratan con nombres de archivos.

=item *

cuando se llaman a las funciones desde el interior del ámbito del I<pragma> S<C<L<use bytes|bytes>>>

Probablemente, debería usarlo, en todo caso, solo para depuración.

=back

=item *

Cadenas -incluyendo las claves hash- y patrones de expresiones regulares pueden contener caracteres con valores ordinales mayores de 255.

Si usa un editor Unicode para editar su programa, los caracteres Unicode pueden ocurrir directamente dentro de las cadenas literales con la codificación UTF-8 o la UTF-16.
(El primero requiere un C<BOM> o un C<use utf8>, el último requiere un C<BOM>).

L<perluniintro/Creando Unicode> le da otras formas de colocar caracteres no-ASCII en sus cadenas.

=item *

Las funciones C<chr()> y C<ord()> trabajan en caracteres completos.

=item *

Las expresiones regulares coinciden con caracteres completos.  Por ejemplo, C<"."> coincide con un carácter completo en lugar de con un único byte.

=item *

El operador C<tr///> traduce por caracteres completos  (Note que se ha eliminado la funcionalidad de C<tr///CU>.  Para una funcionalidad similar, vea C<pack('U0', ...)> y C<pack('C0', ...)>).

=item *

C<scalar reverse()> invierte por caracteres, el lugar de por bytes.

=item *

Los operadores de bit en cadenas, C<& | ^ ~> y (a partir de v5.22)
C<&. |. ^.  ~.>  pueden operar en caracteres que no caben en un byte.
Sin embargo, el comportamiento actual es probable que cambie.  No debería usar estos operadores en cadenas que estén codificadas en UTF-8.  Si no está seguro sobre la codificación de una cadena, degrádela antes de usar estos operadores; puede usar L<C<utf8::utf8_downgrade()>|utf8/Utilería>.

=back

Lo básico es que Perl siempre practica "Semántica de carácter" pero con la llegada de Unicode, esto es diferente de "Semántica de byte".

=head2 Reglas ASCII contra reglas Unicode

Antes de Unicode, cuando un carácter era un byte, que era un carácter, Perl solo sabía de 128 caracteres definidos por el ASCII, del punto de código 0 al 127 (excepto bajo S<C<use locale>>).  Los puntos de código restantes, del 128 al 255 no estaban asignados, y estaban disponibles para lo que cualquier programa quisiera hacer.  Las únicas semánticas que tienen son sus números ordinales, y que no son miembros de ninguna de las clases de carácter no negativos.  Se considera que ninguna coincida con C<\w>, por ejemplo, pero todos coinciden con C<\W>.

Unicode, naturalmente, asigna cada uno de estos puntos de código con un significado particular (junto con los que están por encima del 255).  Para preservar la retrocompatibilidad, Perl solo usa los significados Unicode cuando existe alguna indicación de que es Unicode lo que se pretende; de otra forma, los puntos de código no-ASCII se tratan como si no estuvieran asignados.

Aquí están las formas en que Perl sabe que una cadena tendría que tratarse como Unicode:

=over

=item *

Dentro del ámbito de S<C<use utf8>>

Si todo el programa está en Unicode (significado por usar I<B<U>nicode
B<T>ransformation B<F>ormat>, de 8 bit), entonces todas las cadenas dentro de él deben estar en Unicode.

=item *

Dentro del ámbito de L<S<C<use feature 'unicode_strings'>>|feature/La característica 'unicode_strings'>

Este I<pragma> se creó para que pueda indicar explícitamente a Perl que las operaciones a ejecutar dentro de su ámbito deben seguir las reglas Unicode.  Los nuevos perl tendrán más operaciones afectadas.  Vea L</El "Error de Unicode">.

=item *

Dentro del ámbito de S<C<use 5.012>> o superior

Esto, implícitamente, activa S<C<use feature 'unicode_strings'>>.

=item *

Dentro del ámbito de L<S<C<use locale 'not_characters'>>|perllocale/Unicode y UTF-8>,
o L<S<C<use locale>>|perllocale> y la configuración regional actual es una configuración regional UTF-8.

El primero se define para implicar un manejo Unicode; y el último indica una configuración regional Unicode, y de ahí, una interpretación Unicode de todas las cadenas que hay dentro de él.

=item *

Cuando la cadena contiene un punto de código exclusivamente de Unicode

Perl nunca aceptó puntos de código por encima de 255 sin que sean Unicode, así que su uso implica Unicode para toda la cadena.

=item *

Cuando la cadena contiene un punto de código Unicode nombrado como C<\N{...}>

La construcción C<\N{...}> se refiere explícitamente a un punto de código Unicode, incluso si es uno que también está en ASCII.  Por lo tanto la cadena que lo contiene tiene que ser Unicode.

=item *

Cuando la cadena viene de una fuente externa marcada como Unicode

La opción de línea de comandos L<C<-C>|perlrun/-C [listaE<sol>números]> puede especificar que ciertas entradas al programa estén en Unicode, y los valores se pueden leer desde su código Perl; vea L<perlvar/"${^UNICODE}">.

=item * Cuando la cadena se ha promocionado a UTF-8

La función L<C<utf8::utf8_upgrade()>|utf8/Funciones de utilidad> se puede usar explícitamente para hacer que una cadena se trate de forma permanente (a menos que se llame a una subsecuente C<utf8::utf8_downgrade()>) como Unicode.

=item * Existen métodos adicionales para los patrones de expresiones regulares

Un patrón que se ha compilador con los modificadores C<< /u >> o C<< /a >> se trata como Unicode (aun así existen algunas restricciones con C<< /a >>).
Bajo los modificadores C<< /d >> y C<< /l >>, existen muchas otras indicaciones relacionadas con Unicode; vea L<perlre/Modificadores de conjunto de caracteres>.

=back

Note que todo lo anterior queda sobreescrito dentro del ámbito de C<L<use bytes|bytes>>; pero debería usar este I<pragma> solo para depuración.

Note también que algunas interacciones con el sistema operativo de la plataforma nunca usan las reglas Unicode.

Cuando las reglas Unicode están activas:

=over 4

=item *

Los operadores de traducción de tamaño de caja usan las tablas de traducción de tamaño de caja Unicode.

Note que C<uc()> o C<\U> en cadenas interpoladas, traducen a mayúscula, mientras que C<ucfirst> o C<\u>, en cadenas interpoladas, traducen a capitulares en idiomas que hacen la distinción (que es equivalente a mayúscula en idiomas sin distinción).

Existe un módulo en CPAN, C<L<Unicode::Casing>>, que le permite definir sus propios mapeos en C<lc()>, C<lcfirst()>, C<uc()>, C<ucfirst()> y C<fc> (o en sus versiones incrustadas en cadenas doblemente entrecomilladas, como C<\U>).  (Antes de Perl 5.16, esta funcionalidad se ofrecía parcialmente en el núcleo de Perl, pero sufrió de un cierto número de inconvenientes insuperables, así que, en su lugar, se escribió un módulo de CPAN).

=item *

Las coincidencias de las clases de carácter en expresiones regulares se basan en las propiedades del carácter especificado en la base de datos de propiedades Unicode.

C<\w> se puede usar para coincidir con ideogramas japoneses, por ejemplo; y C<[[:digit:]]> con un número Bengalí.

=item *

Las propiedades Unicode con nombre, scripts, y rangos de bloques se pueden usar (como las clases de carácter entre corchetes) usando la construcción C<\p{}> ("coincide con la propiedad") y la negación C<\P{}>, ("no coincide con la propiedad").

Vea L</"Propiedades de carácter Unicode"> para más detalles.

Puede definir sus propias propiedades de caracteres y usarlas en expresiones regulares con las construcciones C<\p{}> o C<\P{}>.
Vea L</"Propiedades de carácter definidas por el usuario"> para más detalles.

=back

=head2 Agrupaciones de grafemas extendidos (caracteres lógicos)

Considere un carácter, digamos la C<H>.  Podría aparecer con diversas marcas alrededor de ella, como una tilde aguda, o un circunflejo, o varios ganchos, círculos, flechas, etc., sobre, abajo, a un lado o al otro, etc.  Existen muchas posibilidades entre todos los idiomas del mundo.  El número de combinaciones es astronómico, y si existiera un carácter por cada combinación, podría agotarse pronto el millón de caracteres posibles, de Unicode.  Así que Unicode tomó un aproximación diferente: existe un carácter base para la C<H>, y un carácter por cada una de las posibles marcas, y éstos se pueden combinar de diversas formas para obtener el carácter lógico final.  Así que, un carácter lógico -que aparece como un único carácter- puede ser una secuencia de más de un carácter individual.
El estándar Unicode llama a estas "agrupaciones de grafemas extendidas" (I<"extended grapheme clusters">) (que es una versión mejorada del, no hace mucho utilizado, "agrupación de grafemas"); Perl amuebla la construcción de expresiones regulares C<\X> para coincidir completamente con tales secuencias.

Pero la intención de Unicode es unificar los estándares y prácticas actuales de conjuntos de caracteres, y algunos estándares anteriores tienen caracteres únicos que significan lo mismo que algunas de estas combinaciones, como ISO-8859-1, que tiene algunas de ellas. Por ejemplo, C<"LATIN CAPITAL LETTER E WITH ACUTE"> ya formaba parte de este estándar cuando apareció Unicode.
Unicode, por tanto, lo añadió a su repertorio como un único carácter.
Pero este carácter se considera, por parte de Unicode, equivalente a la secuencia consistente del carácter C<"LATIN CAPITAL LETTER E"> seguida del carácter C<"COMBINING ACUTE ACCENT">.

A C<"LATIN CAPITAL LETTER E WITH ACUTE"> se le llama carácter "precompuesto", y a su secuencia equivalente con la "E" y el "COMBINING ACCENT" se le llama equivalencia canónica.  Se dice que todos los caracteres precompuestos tienen una descomposición (en una secuencia equivalente), y el tipo de descomposición se le llama canónica.  Una cadena se puede componer tanto de caracteres precompuestos, o de caracteres enteramente descompuestos.  Unicode las llama, respectivamente, "Normalización de Formas Compuestas" (I<"Normalization Form Composed">) (NFC) y "Normalización de Formas Descompuestas" (I<Normalization Form Decomposed>) (NFD).
El módulo C<L<Unicode::Normalize>> contiene funciones que convierte entre las dos.  Una cadena puede tener también, a la vez, caracteres compuestos y descompuestos; este módulo se puede usar para pasarlo a una de las dos formas.

Se le pueden presentar cadenas en cualquiera de estas formas equivalentes.
No existe nada, actualmente, en Perl 5, que ignore las diferencias.  Así que tendrá que manejarlas de forma especial.  El consejo habitual es el de convertir las entradas a C<NFD> antes de ir más allá.

Para una información más detallada, vea L<http://unicode.org/reports/tr15/>.

=head2 Propiedades de carácter Unicode

(La única vez en que Perl considera una secuencia de puntos de código individuales como un único carácter lógico es en la construcción C<\X>, ya mencionada antes.   Por lo tanto, "carácter", en esta explicación, significa un único punto de código Unicode).

Casi todas las propiedades de carácter Unicode están disponibles en las expresiones regulares usando la construcción C<\p{}> "coincide con la propiedad" y con su negación C<\P{}> "no coincide con la propiedad".

Por ejemplo, C<\p{Uppercase}> hace coincidir cualquier carácter con la propiedad Unicode C<"Uppercase"> ("Mayúscula"), mientras que C<\p{L}> hace coincidir cualquier carácter con la propiedad C<General_Category> ("Categoría general") de C<"L"> (letra) (vea L</General_Category> más abajo).  No se requieren corchetes para nombres de propiedades de letras sueltas, así que C<\p{L}> es equivalente a C<\pL>.

De forma más general, C<\p{Uppercase}> coincide con cualquier carácter cuyo valor de la propiedad Unicode C<Uppercase> sea C<True>, y C<\P{Uppercase}> coincide con cualquier carácter cuyo valor de la propiedad C<Uppercase> sea C<False>, y podrían escribirse como C<\p{Uppercase=True}> y C<\p{Uppercase=False}>, respectivamente.

Esta formalidad es necesaria cuando las propiedades no son binarias, es decir, si pueden tomar más valores que solo C<True> y C<False>.  Por ejemplo, la propiedad C<Bidi_Class> (vea L</"Tipos de caracteres bidireccionales"> más abajo), puede tomar valores diferentes, como C<Left> (izquierda), C<Right> (derecha), C<Whitespace> (espacio en blanco) y otros.  Para coincidir con estos valores, necesita especificar tanto el nombre de la propiedad (C<Bidi_Class>) y el valor contra el que vamos a comparar (C<Left>, C<Right>, etc.).  Esto se hace, como en el ejemplo anterior, teniendo dos componentes separados por el signo de igual (o, alternativamente, por un carácter de dos puntos), como C<\p{Bidi_Class: Left}>.

Todas las propiedades Unicode definidas para caracteres se pueden escribir en esta forma compuesta C<\p{I<propiedad>=I<valor>}> o C<\p{I<propiedad>:I<valor>}>, pero Perl ofrece algunas propiedades adicionales que se escriben de una única forma, así como atajos para todas las propiedades binarias y otras específicas, descritas más abajo, en que puede omitir el nombre de la propiedad y el carácter separador, el igual o el de dos puntos.

La mayor parte de las propiedades Unicode tienen al menos dos sinónimos (o alias, si lo prefiere): una corta que es más fácil de escribir y una más larga que es más descriptiva y, por ello, más fácil de entender.  Así, las propiedades C<"L"> y C<"Letter"> anteriores son equivalentes y se pueden usar de forma alternativa.  Así mismo, C<"Upper"> es un sinónimo para C<"Uppercase">, y podríamos escribir C<\p{Uppercase}> de forma equivalente a C<\p{Upper}>.
También, existen típicamente diversos sinónimos para los valores que puede tener una propiedad.   Para propiedades binarias, C<"True"> tiene 3 sinónimos: C<"T">, C<"Yes"> y C<"Y">; y C<"False"> tiene su correspondiente C<"F">, C<"No"> y C<"N">.  Pero sea prudente.  La forma abreviada de un valor para una propiedad podría no significar lo mismo que la misma forma abreviada de otra.
Así, para la propiedad C<L</General_Category>>, C<"L"> significa C<"Letter">, pero para la propiedad L<C<Bidi_Class>|/Tipos de caracteres bidireccionales>, C<"L"> significa C<"Left">.  La lista completa de propiedades y sinónimos está en L<perluniprops>.

Las diferencias de mayúsculas/minúsculas en los nombres de las propiedades y valores son irrelevantes; así, C<\p{Upper}> significa lo mismo que C<\p{upper}> o incluso C<\p{UpPeR}>.
De forma similar, puede añadir o sustraer guiones bajos en cualquier parte de la palabra, así que las anteriores son también equivalentes a C<\p{U_p_p_e_r}>.  Y el espacio en blanco adyacente entre dos caracteres de puntuación es irrelevante, como las llaves y los separadores de igual y de dos puntos, así que C<\p{   Upper  }> y C<\p{ Upper_case : Y }> también son equivalentes.  De hecho, se puede añadir o borrar espacio en blanco y guiones en cualquier parte.  Así que C<\p{ Up-per case = Yes}> es equivalente.  A todo esto se le llama "loose-matching" (coincidencia floja) por Unicode.  Los pocos sitios donde se usa una coincidencia más estricta es en mitad de los números, y las propiedades de extensión que comienzan o terminan con guión bajo.  La coincidencia estricta se preocupa sobre el espacio en blanco (excepto el adyacente a los caracteres que no forman parte de una palabra), guiones, y guiones bajos que no estén en el interior de una palabra.

También puede usar la negación tanto en C<\p{}> y C<\P{}> introduciendo un circunflejo (C<^>) entre la primera llave y el nombre de la propiedad: C<\p{^Tamil}> es igual a C<\P{Tamil}>.

Casi todas las propiedades son insensibles a la coincidencia independiente del tamaño de caja.  Es decir, añadir el modificador de expresiones regulares C</i> no cambia con lo que ellas coinciden.  Hay dos conjuntos que quedan afectados.
El primer conjunto es C<Uppercase_Letter>, C<Lowercase_Letter>, y C<Titlecase_Letter>, todos aquellos cuales coinciden con C<Cased_Letter> bajo una coincidencia C</i>.
Y el segundo conjunto es C<Uppercase>, C<Lowercase> y C<Titlecase>, todos aquellos cuales coinciden con C<Cased> bajo una coincidencia C</i>.
Este conjunto también incluye sus subconjuntos C<PosixUpper> y C<PosixLower>, los dos bajo la coincidencia C</i> C<PosixAlpha>.
(La diferencia entre estos conjuntos es que algunas cosas, como los numerales Romanos, vienen tanto en mayúsculas o minúsculas, así que son C<Cased> (tienen tamaño de caja), pero no se consideran letras, así que no son C<Cased_Letter>.

Vea L</Más allá de los puntos de código Unicode> para ver consideraciones especiales cuando se coincida propiedades Unicode contra puntos de código no Unicode.

=head3 B<General_Category>

A cada carácter Unicode se le asigna una categoría general, que es la "categorización más usual de un carácter" (de L<http://www.unicode.org/reports/tr44>).

La manera compuesta de escribirlas es así C<\p{General_Category=Number}> (corta: C<\p{gc:n}>).  Pero Perl amuebla atajos en que todo lo que esté a partir del separador de igual o de dos puntos, se omite.  Así que, en lugar de lo anterior, se puede escribir C<\pN>.

Aquí están las formas corta y larga que los valores de la propiedad C<General Category> puede tener:

    Corta       Larga

    L           Letter (letra)
    LC, L&      Cased_Letter (es decir: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter (letra mayúscula)
    Ll          Lowercase_Letter (letra minúscula)
    Lt          Titlecase_Letter (letra capitular)
    Lm          Modifier_Letter (modificador de letra)
    Lo          Other_Letter (otras letras)

    M           Mark (marca)
    Mn          Nonspacing_Mark (marca de no-espacio)
    Mc          Spacing_Mark (marca de espaciado)
    Me          Enclosing_Mark (marca de encierro)

    N           Number (número)
    Nd          Decimal_Number (número decimal) (también Digit (dígito))
    Nl          Letter_Number (letra que es un número)
    No          Other_Number (otro número)

    P           Punctuation (también Punct) (puntuación)
    Pc          Connector_Punctuation (conector de puntuación)
    Pd          Dash_Punctuation (puntuación de guiones)
    Ps          Open_Punctuation (puntuación abierta)
    Pe          Close_Punctuation (puntuación cerrada)
    Pi          Initial_Punctuation (puntuación inicial)
                (se comporta como Ps o Pe dependiendo de su uso)
    Pf          Final_Punctuation (puntuación final)
                (se comporta como Ps o Pe dependiendo de su uso)
    Po          Other_Punctuation (otra puntuación)

    S           Symbol (símbolo)
    Sm          Math_Symbol (símbolo matemático)
    Sc          Currency_Symbol (símbolo monetario)
    Sk          Modifier_Symbol (modificador de símbolo)
    So          Other_Symbol (otro símbolo)

    Z           Separator (separador)
    Zs          Space_Separator (separador de espacio)
    Zl          Line_Separator (separador de línea)
    Zp          Paragraph_Separator (separador de párrafo)

    C           Other (otro)
    Cc          Control (también Cntrl)
    Cf          Format (formato)
    Cs          Surrogate (sustituto)
    Co          Private_Use (uso privado)
    Cn          Unassigned (sin asignar)

Las propiedades de una sola letra coinciden con todos los caracteres de cualquiera de las subpropiedades de dos letras que comiencen con la misma letra.
C<LC> y C<L&> son especiales: las dos son alias para el conjunto consistente de todo lo que coincida con C<Ll>, C<Lu> y C<Lt>.

=head3 B<Tipos de caracteres bidireccionales>

Debido a que los scripts difieren en su direccionalidad (Hebrew y Arábigo se escriben de derecha a izquierda, por ejemplo) Unicode ofrece una propiedad C<Bidi_Class>.
Algunos de los valores que esta propiedad puede tener son:

    Valor       Significado

    L           Left-to-Right (de izquierda a derecha)
    LRE         Left-to-Right Embedding (de izquierda a derecha, incrustando)
    LRO         Left-to-Right Override (de izquierda a derecha, sobreescribiendo)
    R           Right-to-Left (derecha a izquierda)
    AL          Arabic Letter (letra arábiga)
    RLE         Right-to-Left Embedding (de derecha a izquierda, incrustando)
    RLO         Right-to-Left Override (de derecha a izquierda, sobreescribiendo)
    PDF         Pop Directional Format (devuelve el formato direccional)
    EN          European Number (número europeo)
    ES          European Separator (separador europeo)
    ET          European Terminator (terminador europeo)
    AN          Arabic Number (número arábigo)
    CS          Common Separator (separador común)
    NSM         Non-Spacing Mark (marca de no-espacio)
    BN          Boundary Neutral (frontera neutral)
    B           Paragraph Separator (separador párrafo)
    S           Segment Separator (separador de segmentos)
    WS          Whitespace (espacio en blanco)
    ON          Other Neutrals (otros neutrales)

Esta propiedad siempre se escribe en la forma compuesta.
Por ejemplo, C<\p{Bidi_Class:R}> coincide con caracteres que se escriben normalmente de derecha a izquierda.  A diferencia de la propiedad C<L</General_Category>>, a esta propiedad se le puede añadir más valores en una futura edición de Unicode.  Las listadas anteriormente comprendieron el conjunto completo para muchas ediciones de Unicode, pero se añadieron otras en Unicode 6.3; siempre puede encontrar las actuales en L<perluniprops>.  Y L<http://www.unicode.org/reports/tr9/> describe cómo usarlas.

=head3 B<Scripts>

Las lenguas del mundo se escriben en muchos scripts diferentes.  Esta sentencia (a menos que la esté leyendo traducida) está escrita en Latin, mientras que el Ruso se escribe en Cirílico, y el Griego se escribe en, bueno, Griego; el Japones, principalmente, en Hiragana o Katakana.  Hay muchos más.

El C<Script> Unicode y las propiedades C<Script_Extensions> indican en qué script está un carácter dado.  Cualquier propiedad se puede especificar con la forma compuesta, como C<\p{Script=Hebrew}> (corta: C<\p{sc=hebr}>), o C<\p{Script_Extensions=Javanese}> (corta: C<\p{scx=java}>).
Además, Perl amuebla atajos para todos los nombres de propiedad C<Script>.  Puede omitir todo a partir del igual (o del dos puntos), y escribir simplemente C<\p{Latin}> o C<\P{Cyrillic}>.
(Esto no es verdad para las C<Script_Extensions>, que se requiere que se escriban en forma compuesta).

La diferencia entre estas dos propiedades implica caracteres que se usan en múltiples scripts.  Por ejemplo, los dígitos '0' a '9' se usan en muchas partes del mundo.  Se colocan en un script que se llama C<Common>.  Otros caracteres se usan en unos pocos scripts.  Por ejemplo, el C<"KATAKANA-HIRAGANA DOUBLE HYPHEN"> se usa tanto en scripts Japoneses, Katakana e Hiragana, pero en ninguno más.  La propiedad C<Script> coloca todos los caracteres que se usan en múltiples scripts en el script C<Common>, mientras que la propiedad C<Script_Extensions> coloca los que se usan en unos pocos scripts en cada uno de aquellos; mientras, se sigue usando C<Common> para los que se usan en muchos scripts.  Así, estos dos coinciden:

 "0" =~ /\p{sc=Common}/     # Coincide
 "0" =~ /\p{scx=Common}/    # Coincide

y solo el primero de estos coincide:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Common}  # Coincide
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Common}  # No coincide

Y solo los dos últimos coinciden:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Hiragana}  # No coincide
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Katakana}  # No coincide
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Hiragana} # Coincide
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Katakana} # Coincide

C<Script_Extensions>, entonces, es un C<Script> mejorado, en que contiene menos caracteres en el script C<Common> y, correspondientemente, más en otros scripts.  Es nuevo en Unicode versión 6.0, y sus datos es probable que cambien significativamente en las siguientes ediciones, cuando las cosas se pongan en orden.
El nuevo código debería, probablemente, usar C<Script_Extensions>, y no un simple C<Script>.

(De hecho, además de C<Common>, el script C<Inherited>, contiene caracteres que se usan en múltiples scripts.  Existen caracteres modificadores que heredan el valor de script del carácter controlador.  Algunos de estos se usan en muchos scripts, y así, van en C<Inherited> tanto los que están en C<Script> como en C<Script_Extensions>.
Otros se usan en solo unos pocos scripts, así que están C<Inherited> en
C<Script>, pero no en C<Script_Extensions>).

Vale acentuar que existen muchos conjuntos diferentes de dígitos en Unicode que son equivalentes a 0-9 y que coinciden con C<\d> en una expresión regular.  Si se usan en una única lengua, existen en el C<Script> y en el C<Script_Extension> de esa lengua.  Si se usan en más de un script, estarán en C<sc=Common>, pero solo si se usan en muchos scripts, deberían estar en C<scx=Common>.

La lista completa de scripts y sus atajos está en L<perluniprops>.

=head3 B<Uso del prefijo C<"Is">>

Por retrocompatibilidad (con Perl 5.6), todas las propiedades que se pueden escribir sin usar la forma compuesta mencionadas antes tienen añadida C<Is> o C<Is_> a su nombre, asi que C<\P{Is_Lu}>, por ejemplo, es igual a C<\P{Lu}> y C<\p{IsScript:Arabic}> es igual a C<\p{Arabic}>.

=head3 B<Blocks>

Además de los B<scripts>, Unicode también define B<blocks> (bloques) de caracteres.  La diferencia entre scripts y bloques es que el concepto de script está más cercano al lenguaje natural, mientras que el concepto de bloques es más una agrupación artificial basada en grupos de caracteres Unicode con valores ordinales consecutivos. Por ejemplo, el bloque C<"Basic Latin"> tiene todos los caracteres cuyos ordinales están entre el 0 y el 127, inclusive; en otras palabras, los caracteres ASCII.  El script C<"Latin"> contiene algunas de estas letras así como de otros muchos otros bloques, como C<"Latin-1 Supplement">, C<"Latin Extended-A">, etc., pero no contiene todos los caracteres de estos bloques. No contiene por ejemplo, los dígitos 0-9, porque los dígitos se comparten entre muchos scripts, y por eso están en el script C<Common>.

Para más información de scripts contra bloques, vea UAX#24 "Unicode Script Property": L<http://www.unicode.org/reports/tr24>

Las propiedades C<Script> o C<Script_Extensions> probablemente puedan ser las únicas que quiera utilizar cuando procese lenguaje natural; la propiedad C<Block> puede, ocasionalmente, ser útil trabajando con las tripas de Unicode.

Se coincide con los nombres de bloque en la forma compuesta, como C<\p{Block: Arrows}> o C<\p{Blk=Hebrew}>.  A diferencia de la mayoría de las demás propiedades, solo unos pocos nombres de bloques definidos por Unicode tienen un nombre acortado.

Perl también define sinónimos de formato único para la propiedad bloque en casos donde no exista conflicto con nada más.  Pero no use ninguno de ellos, porque son inestables.  Ya que estas son extensiones Perl, están subordinadas a los nombres de propiedades oficiales de Unicode; Unicode no sabe ni le preocupan las extensiones Perl.  Podría suceder que un nombre que, actualmente, es una extensión Perl, más tarde se cambiará, sin previo aviso, a una propiedad Unicode diferente, en una futura versión del interprete perl, que use la última distribución Unicode, y su código dejaría de funcionar.  Las extensiones se mencionan aquí como complemento a la documentación: Tome el nombre del bloque y prefíjalo con uno de los siguientes: C<In> (por ejemplo C<\p{Blk=Arrows}> se puede escribir ahora como C<\p{In_Arrows}>); o algunas veces C<Is> (como C<\p{Is_Arrows}>); o algunas veces sin ningún prefijo (C<\p{Arrows}>).  En el momento de escribir esto (Unicode 8.0) no existen conflictos usando el prefijo C<In_>, pero hay un montón con las otras dos formas.  Por ejemplo, C<\p{Is_Hebrew}> y C<\p{Hebrew}> significan C<\p{Script=Hebrew}> que NO es la misma cosa que C<\p{Blk=Hebrew}>.  Nuestro consejo es el de que use el prefijo C<In_> como el único formato para especificar un bloque.  Pero Unicode 8.0 sumó propiedades cuyos nombres comienzan con C<In>, y ahora queda claro que es solo cuestión de suerte que se impida un conflicto.  Usar C<In> es, marginalmente, más corto -a la hora de escribirlo- que C<Blk:>, y el significado de este último es, de todas formas, más clara, y garantizado que nunca entrará en conflicto.  Así que... no se la juegue.  Use C<\p{Blk=foo}> en los nuevos programas.  Y asegúrese de que ese bloque es lo que realmente quiere hacer.  En la mayor parte de los casos, estos I<scripts> son realmente lo que quiere hacer.

La lista completa de bloques está en L<perluniprops>.

=head3 B<Otras propiedades>

Existen muchas más propiedades que las más básicas, descritas aquí.
Una lista completa está en L<perluniprops>.

Unicode define todas sus propiedades en la forma compuesta, así que todas las propiedades con una sola forma, son extensiones Perl.  La mayoría de estas son solo sinónimos de las de Unicode, pero algunas son extensiones genuinas, incluyendo varias que están en la forma compuesta.  Y bastantes de estas están, actualmente, recomendadas por Unicode (en L<http://www.unicode.org/reports/tr18>).

Esta sección ofrece algunos detalles sobre todas las extensiones que no son solo sinónimos para las propiedades compuestas de Unicode (para estas propiedades, tendrá que referirse al L<estándar Unicode|http://www.unicode.org/reports/tr44>.

=over

=item B<C<\p{All}>>

Esto coincide con cada punto de código posible.  Es equivalente a C<qr/./s>.
A diferencia de todas las demás coincidencias de propiedades C<\p{}> no definidas por el usuario, nunca se genera una advertencia si esta propiedad se hace coincidir de nuevo contra un punto de código no Unicode (vea L</Más allá de los puntos de código Unicode> más abajo).

=item B<C<\p{Alnum}>>

Esto coincide con cualquier carácter C<\p{Alphabetic}> o C<\p{Decimal_Number}>.

=item B<C<\p{Any}>>

Esto coincide con cualquiera de los 1_114_112 puntos de código.  Es un sinónimo para C<\p{Unicode}>.

=item B<C<\p{ASCII}>>

Esto coincide con cualquiera de los 128 caracteres en el conjunto de caracteres US-ASCII, que es un subconjunto de Unicode.

=item B<C<\p{Assigned}>>

Esto coincide con cualquier punto de código asignado, es decir, cualquier punto de código cuya L<categoría general|/General_Category> no sea C<Unassigned> (sin asignar) (o, de forma equivalente, que no esté en C<Cn>).

=item B<C<\p{Blank}>>

Esto es lo mismo que C<\h> y C<\p{HorizSpace}>: Un carácter que cambia el espaciado horizontalmente.

=item B<C<\p{Decomposition_Type: Non_Canonical}>>    (corto: C<\p{Dt=NonCanon}>)

Coincide con un carácter que tiene una descomposición no canónica.

La sección anterior L</Agrupaciones de grafemas extendidos (caracteres lógicos)> hablaba sobre las descomposiciones canónicas.  Sin embargo, muchos más caracteres tienen un tipo diferente de descomposición, una "compatible" o "no canónica".  Las secuencias que forman estas descomposiciones no se consideran canónicamente equivalentes al carácter precompuesto.  Un ejemplo es C<"SUPERSCRIPT ONE">.  Es un poco como el dígito normal 1, pero no exactamente; su descomposición en el dígito 1 se llama una descomposición "compatible", específicamente una "super" descomposición.  Existen diversas descomposiciones con tal compatibilidad (vea L<http://www.unicode.org/reports/tr44>), incluyendo una que se llama "compat", que significa algún tipo variado de descomposición que no encaja en las otras categorías de descomposición que Unicode escogió.

Note que la mayor parte de los caracteres Unicode no tiene una descomposición, así que su tipo de descomposición es C<"None"> (ninguno).

Para su comodidad, Perl añadió el tipo de descomposición C<Non_Canonical> para significar cualquiera de las diversas descomposiciones de compatibilidad.

=item B<C<\p{Graph}>>

Coincide con cualquier carácter que sea gráfico.  Teóricamente, esto significa un carácter en que una impresora necesite usar tinta para poder mostrarle.

=item B<C<\p{HorizSpace}>>

Esto es lo mismo que C<\h> y C<\p{Blank}>: Un carácter que cambia el espaciado horizontalmente.

=item B<C<\p{In=*}>>

Es un sinónimo para C<\p{Present_In=*}>.

=item B<C<\p{PerlSpace}>>

Esto es lo mismo que C<\s>, restringido al ASCII, concrétamente C<S<[ \f\n\r\t]>>
y a partir de Perl v5.18, un tabulador vertical.

Mnemónico: el espacio (original) de Perl.

=item B<C<\p{PerlWord}>>

Esto es lo mismo que C<\w>, restringido a ASCII, concretamente C<[A-Za-z0-9_]>

Mnemónico: la palabra (original) de Perl.

=item B<C<\p{Posix...}>>

Existen muchos de estos, que son equivalentes, usando la notación C<\p{}>, para las clases Posix y se describen en L<perlrecharclass/Clases de carácter POSIX>.

=item B<C<\p{Present_In: *}>>    (corto: C<\p{In=*}>)

Esta propiedad se usa cuando necesita saber en qué versión de Unicode se encuentra un carácter.

El "*" anterior es un espacio reservado para dos dígitos que representan el número de versión Unicode, como C<1.1> o C<4.0>; o incluso también puede ser C<Unassigned>.  Esta propiedad coincidirá con los puntos de código cuya disposición final se resolvió en el número de versión indicado; C<\p{Present_In: Unassigned}> coincidirá con aquellos puntos de código cuyo significado tiene, todavía, que asignarse.

Por ejemplo, C<U+0041> C<"LATIN CAPITAL LETTER A"> se presentó en la primerísima edición de Unicode disponible, que es la C<1.1>, así que esta propiedad es verdadera para todas las versiones "*".  Por otro lado, C<U+1EFF> no se asignó hasta la versión 5.1 cuando se convirtió en C<"LATIN SMALL LETTER Y WITH LOOP">, así que el único "*" con el que podría coincidir sería 5.1, 5.2 y superior.

Unicode amuebla la propiedad C<Age> del que deriva esto último.  El problema con Age es que una interpretación estricta de él (que Perl toma) hace que coincida con la edición precisa del momento en que se introdujo el significado de un punto de código.  Así C<U+0041> coincidiría solo con 1.1; y C<U+1EFF> solo con 5.1.  Esto no es lo que normalmente quiere.

Algunas implementaciones, que no son Perl, de la propiedad Age puede cambiar su significado a lo mismo que la propiedad C<Present_In> de Perl; sea consciente de esto.

Otra confusión con ambas propiedades es que el punto de código no tenía I<asignada> la definición, si no que el significado del punto de código estaba I<determinado>.  Esto es porque 66 puntos de código siempre quedarán sin asignar, y por lo tanto la C<Age> para ellas es la versión Unicode en que se tomó esa decisión.  Por ejemplo, C<U+FDD0> queda permanentemente sin asignar a ningún carácter, y la decisión de hacer esto fue en la versión 3.1, así que C<\p{Age=3.1}> coincide con este carácter, y también con C<\p{Present_In: 3.1}> y superiores.

=item B<C<\p{Print}>>

Coincide con cualquier carácter que es gráfico o blanco, excepto caracteres de control.

=item B<C<\p{SpacePerl}>>

Es lo mismo que C<\s>, incluyendo más allá del ASCII.

Mnemónico: I<Space> (espacio), tal como lo entiende Perl.  (No incluye el tabulador vertical hasta la v5.18, en que tanto el estándar Posix como el Unicode lo consideran espacio en blanco).

=item B<C<\p{Title}>> y B<C<\p{Titlecase}>>

Bajo la coincidencia sensible al tamaño de caja, estas dos coinciden con los mismos puntos de código como C<\p{General Category=Titlecase_Letter}> (C<\p{gc=lt}>).  La diferencia es que bajo la coincidencia insensible al tamaño de caja C</i>, coinciden con lo mismo que con C<\p{Cased}>, mientras que C<\p{gc=lt}> coincide con C<\p{Cased_Letter>).

=item B<C<\p{Unicode}>>

Esto coincide con cualquiera de los 1_114_112 puntos de código.
C<\p{Any}>.

=item B<C<\p{VertSpace}>>

Esto es lo mismo que C<\v>: Un carácter que cambia el espaciado vertical.

=item B<C<\p{Word}>>

Esto es lo mismo que C<\w>, incluyendo más de 100 000 caracteres más allá de ASCII.

=item B<C<\p{XPosix...}>>

Existen muchas de este tipo, que son las clases estándares Posix extendidas a todo el rango Unicode.  Están descritas en L<perlrecharclass/Clases de carácter POSIX>.

=back


=head2 Propiedades de carácter definidas por el usuario

Puede definir sus propias propiedades binarias de carácter definiendo subrutinas cuyos nombres comiencen con C<"In"> o C<"Is">.  (La característica experimental L<perlre/(?[ ])> ofrece una alternativa que ofrece definiciones más complejas).  Las subrutinas se pueden definir en cualquier paquete.  Las propiedades definidas por el usuario se pueden usar en las construcciones C<\p{}> y C<\P{}> de expresiones regulares; si está usando una propiedad definida por el usuario desde un paquete distinto del que se encuentra, debe especificar su paquete en las construcciones C<\p{}> o C<\P{}>.

    # supongamos que la propiedad Is_Foreign está definida en Lang::
    package main;  # se requiere el nombre del paquete de la propiedad 
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }

    package Lang;  # no se requiere el nombre del paquete de la propiedad 
    if ($txt =~ /\p{IsForeign}+/) { ... }


Note que el efecto es en tiempo de compilación, e inmutable una vez definido.
Sin embargo, las subrutinas se pasan como un único parámetro, que es 0 si está en efecto la coincidencia sensible al tamaño de caja, y distinto de cero si está en efecto la coincidencia insensible al tamaño de caja.  La subrutina puede devolver diferentes valores dependiendo del valor del indicador, y un conjunto de valores será inmutable para todas las coincidencias sensibles al tamaño de caja, y el otro conjunto para todas las coincidencias insensibles al tamaño de caja.

Note que si la expresión regular está entintada, entonces Perl morirá en lugar de llamar a la subrutina cuando el nombre de la subrutina se determina por los datos entintados.

Las subrutinas deben devolver una cadena formateada de forma especial, con una o más líneas separadas por caracteres de nueva línea.  Cada línea debe ser una de las siguientes:

=over 4

=item *

Un único número hexadecimal que denota un punto de código que hay que incluir.

=item *

Dos números hexadecimales separados por espacio horizontal (caracteres de espacio o tabuladores) denotando un rango de puntos de código que hay que incluir.

=item *

Algo para incluir, prefijado por C<"+">: una propiedad de caracteres predefinida (prefijada por C<"utf8::">) o una propiedad definida por el usuario totalmente cualificada (incluyendo el nombre del paquete), para representar todos los caracteres de esa propiedad; dos puntos de código hexadecimales para un rango; o un único punto de código hexadecimal.

=item *

Algo para excluir, prefijado por C<"-">: una propiedad actual de caracteres (prefijada por C<"utf8::">) o una propiedad definida por el usuario totalmente cualificada (incluyendo el nombre del paquete), para representar todos los caracteres de esa propiedad; dos puntos de código hexadecimales para un rango; o un único punto de código hexadecimal.

=item *

Algo para negar, prefijado por C<"!">: una propiedad actual de caracteres (prefijada por C<"utf8::">) o una propiedad definida por el usuario totalmente cualificada (incluyendo el nombre del paquete), para representar todos los caracteres de esa propiedad; dos puntos de código hexadecimales para un rango; o un único punto de código hexadecimal.

=item *

Algo con el que cruzarse, prefijado por C<"&">: una propiedad actual de caracteres (prefijada por C<"utf8::">) o una propiedad definida por el usuario totalmente cualificada (incluyendo el nombre del paquete), para todos los caracteres excepto los caracteres de la propiedad; dos puntos de código hexadecimales para un rango; o un único punto de código hexadecimal.

=back

Por ejemplo, para definir una propiedad que cubre los dos silabarios Japoneses (hiragana y katakana), puede definir

    sub InKana {
        return <<END;
    3040\t309F
    30A0\t30FF
    END
    }

Imagine que la marca final del here-doc (documento incrustado) es el comienzo de la línea.
Ahora puede usar C<\p{InKana}> y C<\P{InKana}>.

También podría usar nombres actuales de propiedades de bloques:

    sub InKana {
        return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }

Suponga que quiere hacer coincidir solo los caracteres asignados, no los rangos de bloque en crudo: en otras palabras, quiere eliminar los caracteres sin asignar:

    sub InKana {
        return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }

La negación es útil para definir (¡sorpresa!) clases negadas.

    sub InNotKana {
        return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }

Esto coincidirá con todos los puntos de código que no estén en Unicode, ya que cada uno de ellos no está en Kana.  Puede usar intersección para excluir para excluirlos, si lo desea, como muestra en este ejemplo modificado:

    sub InNotKana {
        return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    &utf8::Any
    END
    }

C<&utf8::Any> debe ser la última línea de la definición.

La intersección se usa generalmente para obtener los caracteres comunes que coincidan con dos (o más) clases.  Es importante recordar no usar C<"&"> para el primer conjunto; podría hacer la intersección con nada, resultando en un conjunto vacío.

A diferencia de las coincidencias con propiedades C<\p{}> no definidas por el usuario, nunca se genera una advertencia si estas propiedades se hacen coincidir de nuevo contra un punto de código no Unicode (vea L</Más allá de los puntos de código Unicode> más abajo).

=head2 Mapeos de tamaño de caja definidos por el usuario (solo para I<hackers> serios)

B<Esta característica se ha eliminado de Perl 5.16>. El módulo de CPAN C<L<Unicode::Casing>> proporciona una mejor funcionalidad sin los inconvenientes que tuvo esta característica.  Si está usando un Perl anterior a 5.16, esta característica se documento completamente en la versión 5.14 de este pod: L<http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29>

=head2 Codificaciones de carácter para entrada y salida

Vea L<Encode>.

=head2 Nivel de soporte de expresiones regulares para Unicode

La lista siguiente de características soportadas por Unicode para expresiones regulares describe todas las características soportadas actualmente de forma directa por el núcleo de Perl.  Las referencias a "Nivel N" y la sección de números se refiere al estándar técnico de Unicode #18 (I<Unicode Technical Standard #18>), "I<Unicode Regular Expressions>", versión 13, de agosto de 2008.

=over 4

=item *

Nivel 1 - Soporte básico de Unicode

 RL1.1   Notación hex.                    - hecho         [1]
 RL1.2   Propiedades                      - hecho         [2][3]
 RL1.2a  Propiedades de compatibilidad    - hecho         [4]
 RL1.3   Substracción e intersección      - experimental  [5]
 RL1.4   Fronteras sencillas de palabras  - hecho         [6]
 RL1.5   Coincidencias ligeras sencillas  - hecho         [7]
 RL1.6   Fronteras de líneas              - FALTA         [8][9]
 RL1.7   Puntos de código suplementarios  - hecho         [10]

=over 4

=item [1] C<\N{U+...}> y C<\x{...}>

=item [2] C<\p{...}> C<\P{...}>

=item [3] soporte no solo las listas mínimas, sino todas las propiedades de caracteres Unicode (vea Propiedades de carácter Unicode, más arriba)

=item [4] C<\d> C<\D> C<\s> C<\S> C<\w> C<\W> C<\X> C<[:I<prop>:]>
C<[:^I<prop>:]>

=item [5] La característica experimental a partir de v5.18 C<"(?[...])"> cumple con esto.

Vea L<perlre/(?[ ])>.  Si no quiere usar una característica experimental, puede usar una de las siguientes:

=over 4

=item *

Expresión regular de inspección hacia adelante

Puede imitar la substracción de clases usando una exp. reg. adelantada.
Por ejemplo, lo que UTS#18 podría escribirse como

    [{Block=Greek}-[{UNASSIGNED}]]

en Perl se podría escribir como:

    (?!\p{Unassigned})\p{Block=Greek}
    (?=\p{Assigned})\p{Block=Greek}

Pero en este ejemplo en particular, lo más probable es que realmente quiera

    \p{Greek}

que coincidirá con caracteres asignados que se sabe que forman parte del I<script> del Griego.

=item *

Módulo de CPAN C<L<Unicode::Regex::Set>>

Implementa completamente la sintaxis de agrupación, intersección, unión y sustracción de UTS#18.

=item *

L</"Propiedades de carácter definidas por el usuario">

C<"+"> para unión, C<"-"> para eliminación (diferencia de conjuntos), C<"&"> para intersección

=back

=item [6] C<\b> C<\B>

=item [7]
Note que Perl hace un plegado B<I<Full>> (completo) en las coincidencias, no B<Simple>:

Por ejemplo, C<U+1F88> es equivalente a C<U+1F00 U+03B9>, en lugar de solo C<U+1F80>.  Esta diferencia importa, principalmente, para ciertas letras capitales de Griego con ciertos modificadores: el plegado completo descompone la letra, mientras que el plegado simple mapeará a un único carácter.

=item [8]
Perl trata C<\n> como un delimitador de principio y fin de línea.  Unicode especifica más caracteres que tendrían que interpretarse.

Son los siguientes:

 VT   U+000B  (\v en C)
 FF   U+000C  (\f)
 CR   U+000D  (\r)
 NEL  U+0085
 LS   U+2028
 PS   U+2029

Se supone que C<^> y C<$> coincidirían en los patrones de expresiones regulares con todos estos caracteres, pero no es así.
Estos caracteres también deberían, pero no es así, afectar a C<< <> >> C<$.>, y números de líneas del script.

También, las líneas no deberían dividirse por el interior de C<CRLF> (es decir, no existe una línea vacía entre C<\r> y C<\n>).  Para C<CRLF>, pruebe la capa C<:crlf> (vea L<PerlIO>).

=item [9] Pero C<qr/\b{lb}/> y C<L<Unicode::LineBreak>> están disponibles.

L<C<qrE<sol>\b{lb}E<sol>>|perlrebackslash/\b{lb}> ofrece un sistema de ruptura de línea, por defecto, conforme a L<UAX#14 "Unicode Line Breaking Algorithm"|http://www.unicode.org/reports/tr14>.

Y, el módulo C<L<Unicode::LineBreak>> también es conforme a UAX#14, ofrece una ruptura de línea personalizable.

=item [10]
UTF-8/UTF-EBDDIC utilizado en Perl, permite no solo C<U+10000> a C<U+10FFFF>, sino más allá de C<U+10FFFF>

=back

=item *

Nivel 2 - Soporte extendido de Unicode

 RL2.1   Equivalentes canónicos          - FALTA         [10][11]
 RL2.2   Agrup. de grafemas por defecto  - FALTA         [12]
 RL2.3   Fronteras de palabras por def.  - HECHO         [14]
 RL2.4   Coincidencias ligeras por def.  - FALTA         [15]
 RL2.5   Propiedades de los nombres      - HECHO
 RL2.6   Propiedades de los comodines    - FALTA

 [10] vea UAX#15 "Unicode Normalization Forms"
 [11] tiene a Unicode::Normalize pero no está integrado en las I<regexp>
 [12] tiene a \X y \b{gcb} pero no tenemos un "Grapheme Cluster
      Mode"
 [14] vea UAX#29, Word Boundaries
 [15] Esto se explica en el capítulo 3.13 (en Unicode 6.0)

=item *

Nivel 3 - Soporte a medida

 RL3.1   Puntuación a medida             - FALTA
 RL3.2   Agrup. de grafemas a medida     - FALTA         [17][18]
 RL3.3   Fronteras de palabras a medida  - FALTA
 RL3.4   Coincidencias ligeras a medida  - FALTA
 RL3.5   Rangos a medida                 - FALTA
 RL3.6   Coincidencia de contexto        - FALTA         [19]
 RL3.7   Coincidencia incremental        - FALTA
      ( RL3.8   Compartiendo el conjunto Unicode )
 RL3.9   Conjuntos de coincid. posibles  - FALTA
 RL3.10  Coincidencia de plegamiento     - FALTA         [20]
 RL3.11  subcoincidencias                - FALTA

 [17] vea UAX#10 "Unicode Collation Algorithms"
 [18] tiene a Unicode::Collate pero no está integrado en las I<regexp>
 [19] tiene (?<=x) y (?=x), pero las inspecciones hacia adelante o hacia atrás
      tendrían que verse fuera de la subcadena objetivo
 [20] necesita coincidencia insensible para las características lingüísticas diferentes
      del tamaño de caja; por ejemplo, hiragana a katakana, ancho y
      estrecho, de Han simplificado a Han tradicional (vea UTR#30
      "Character Foldings")

=back

=head2 Codificaciones Unicode

Los caracteres Unicode se asignan a I<puntos de código>, que son números abstractos.  Para usar estos números, se necesitan diversas codificaciones.

=over 4

=item *

UTF-8

UTF-8 es una codificación independiente del orden de los bytes, y de longitud variable (de 1 a 4 bytes).  En la mayor parte de la documentación de Perl, incluyendo otras partes de este documento, el término "UTF-8" significa también "UTF-EBCDIC".  Pero en esta sección, "UTF-8" se refiere solo a la codificación que se usa en las plataformas ASCII.  Es un superconjunto del de 7 bit US-ASCII, así que cualquier cosa que se codifique en ASCII, tiene que su representación es igual cuando se codifica en UTF-8.

La siguiente tabla se toma de Unicode 3.2.

 Puntos de código       1er Byte  2do Byte  3er Byte 4to Byte

   U+0000..U+007F       00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF       E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++ sustituye utf16, no legal en utf8 +++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF

Note los espacios vacíos marcados con "*" antes de muchas de las entradas de byte anteriores.  Son debidas a código UTF-8 legal que evita codificaciones no abreviadas: es técnicamente posible codificar en UTF-8 el mismo punto de código de formas diferentes, pero esto está explícitamente prohibido, y siempre se debe usar la codificación posible más corta (y es lo que Perl hace).

Otra forma de verlo es a través de los bit:

                Punt. cód.   1er Byte  2do Byte  3er Byte  4to Byte

                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa

Como puede ver, los bytes de continuación comienzan todos por C<"10">, y los bit principales del byte de inicio indican cuántos bytes existen en el carácter codificado.

La especificación original UTF-8 permitía hasta 6 bytes, para poder codificar números hasta el C<0x7FFF_FFFF>.  Perl sigue permitiéndolos, y lo ha extendido hasta los 13 bytes para codificar puntos de código que entren en una palabra de 64-bit.  Sin embargo, Perl sacará una advertencia si pinta alguno de estos caracteres, diciendo que es algo no portable; y en protocolos de entrada con UTF-8 estricto, están prohibidos.  Además, es obsoleto usar un punto de código mayor que lo que pueda almacenarse en una variable entera con signo, en su sistema.  En sistemas ASCII de 32 bit, esto significa C<0x7FFF_FFFF> es el máximo legal yendo hacia arriba (mucho mayor en sistemas 64 bit).

=item *

UTF-EBCDIC

Como UTF-8, pero EBCDIC-seguro, en la forma que UTF-8 es ASCII-seguro.
Esto significa que todos los caracteres básicos (que incluyen a todos aquellos que tengan equivalentes en ASCII (como C<"A">, C<"0">, C<"%">, I<etc.>) son los mismos tanto en EBCDIC como en UTF-EBCDIC).

UTF-EBCDIC se usa en plataformas EBCDIC.  Requiere generalmente más bytes para representar un punto de código que lo que UTF-8 hace; los puntos de código Unicode más grandes toman 5 bytes para representarlos (en lugar de los 4 en UTF-8), y extendido para las palabras de 64 bit, usa 14 bytes en lugar de los 13 bytes de UTF-8.

=item *

UTF-16, UTF-16BE, UTF-16LE, Sustitutos y C<BOM> (Byte Order Marks -Marcas de ordenes de byte-)

Los siguientes elementos son en su mayor parte para referencia y conocimiento general de Unicode, Perl no usa estas construcciones, internamente.

Igual que con UTF-8, UTF-16 es una codificación de ancho variable, pero mientras UTF-8 usa unidades de 8 bit, UTF-16 usa unidades de código de 16 bit.
Todos los puntos de código ocupan, tanto 2 como 4 bytes, en UTF-16: los puntos de código C<U+0000..U+FFFF> se almacenan en una única unidad de 16 bit, y los puntos de código C<U+10000..U+10FFFF> en dos unidades de 16 bit.  El último caso usa sustitutos (I<surrogates>), siendo la primera unidad de 16 bit el I<sustituto alto>, y la segunda, el I<sustituto bajo>.

Los Sustitutos son puntos de código puestos aparte para codificar el rango C<U+10000..U+10FFFF> de puntos de código Unicode en pares de unidades de 16 bit.  El I<sustituto alto> es el rango C<U+D800..U+DBFF> y el I<sustituto bajo> es el rango C<U+DC00..U+DFFF>.  La codificación de sustitutos es

    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;

y la codificación es

    $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);

Debido a la propiedad de tener 16 bit, UTF-16 depende del orden de los bytes.  El propio UTF-16 se puede usar para cálculos en memoria, pero si se requiere almacenar o transferir, se debe elegir entre las codificaciones UTF-16BE (I<big endian>) o UTF-16LE (I<little endian>).

Esto presente otro problema: ¿qué pasa si sabe que sus datos están en UTF-16, pero no sabe la ordenación de esos bytes?  Las marcas de orden de bytes (I<Byte Order Marks> o C<BOM>), es una solución para ese problema.  Se ha reservado en Unicode un carácter especial para funcionar como marcador de orden de byte: el carácter con punto de código C<U+FEFF> es la C<BOM>.

El truco está en que si lee un C<BOM>, sabe el orden de los bytes, ya que si se escribió en una plataforma I<big endian>, lo leerá los bytes C<0xFE 0xFF>, pero si se escribió en una plataforma I<little endian>, leerá los bytes C<0xFF 0xFE>.  (Y si la plataforma original donde se escribió era una UTF-8 basada en ASCII, leerá los bytes C<0xEF 0xBB 0xBF>).

La forma de trabajar de este truco es que el carácter con un punto de código C<U+FFFE>, se supone que no debe existir en un flujo de entrada, así que la secuencia de bytes C<0xFF 0xFE> es, sin ambigüedad, "C<BOM>, representada en formato I<little endian>" y no puede ser C<U+FFFE>, "representado en formato I<big endian>".

Los sustitutos no tienen significado en Unicode fuera de su uso en pares para representar otros puntos de código.  Sin embargo, Perl permite que se les represente de forma individual, internamente, por ejemplo, diciendo C<chr(0xD801)>, así que todos los puntos de código, no solo los válidos para el intercambio abierto, son representables.  Unicode define semánticas para ellos, como su C<L</General_Category>>, que es C<"Cs">.  Pero debido a que su uso es algo peligroso, Perl lo advertirá (usando la categoría de advertencias C<"surrogate">, que es una subcategoría de C<"utf8">) si se intentan hacer cosas como tomar la forma baja del tamaño de caja de uno de ellos, o hacer una coincidencia insensible al tamaño de caja, o el imprimirles.  (Pero no intente hacer esto en Perl anteriores a 5.14).

=item *

UTF-32, UTF-32BE, UTF-32LE

La familia UTF-32 se parece mucho a la familia UTF-16, excepto que las unidades son de 32 bit, y por lo tanto, no necesita el esquema de sustitutos.  UTF-32 es una codificación de ancho fijo.  Las firmas C<BOM> son C<0x00 0x00 0xFE 0xFF> para BE (I<big endian>) y C<0xFF 0xFE 0x00 0x00> para LE (I<little endian>).

=item *

UCS-2, UCS-4

Antiguas codificaciones de ancho fijo definidas por el estándar ISO 10646.  UCS-2 es una codificación de 16 bit.  A diferencia de UTF-16, UCS-2 no se extiende más allá de C<U+FFFF>, porque no usa sustitutos.  UCS-4 es una codificación de 32 bit, funcionalmente idéntica a UTF-32 (la diferencia es que UCS-4 no prohíbe ni los sustitutos ni los puntos de código superiores a C<0x10_FFFF>).

=item *

UTF-7

Una codificación segura de siete bit (sin octavo bit), que es útil si el transporte o almacenamiento no es seguro con el octavo bit.  Se define en el RFC 2152.

=back

=head2 Puntos de código sin caracteres

Existen 66 puntos de código que se han puesto aparte, en Unicode, como "puntos de código sin carácter".
Todos ellos tienen C<Unassigned> (C<Cn>) C<L</General_Category>>, y no se asignará ningún carácter a ninguno de ellos.  Existen 32 puntos de código entre C<U+FDD0> y C<U+FDEF>, inclusives,  y los 34 puntos de código:

 U+FFFE   U+FFFF
 U+1FFFE  U+1FFFF
 U+2FFFE  U+2FFFF
 ...
 U+EFFFE  U+EFFFF
 U+FFFFE  U+FFFFF
 U+10FFFE U+10FFFF

Hasta Unicode 7.0, los no-caracteres estaban "B<prohibidos> para uso en intercambio abierto de datos de texto Unicode", así que el código que procesa estos flujos podrían usar estos puntos de código como centinelas que podrían mezclarse con los datos de caracteres, y siempre podrían distinguirse de esos datos.
(Se ha añadido énfasis en el párrafo anterior y en el siguiente de este documento).

Unicode 7.0 cambió la redacción, así que son "B<no recomendado> para usar en intercambio abierto de datos de texto Unicode".  El estándar 7.0 va a decir:

=over 4

"Si un no-carácter se recibe en un intercambio abierto, no es necesaria ninguna aplicación para interpretarlo.  Es una buena práctica, sin embargo, reconocerlo como un no-carácter y tomar la acción apropiada, como reemplazarlo por el carácter de reemplazo C<U+FFFD>, para indicar este problema en el texto.  No se recomienda el simple borrado del texto de los puntos de código de los no-caracteres, debido a potenciales problemas de seguridad provocados por el borrado de caracteres no interpretados.  (Vea la cláusula de conformidad C7 en la sección 3.2, I<Conformance Requirements> (requerimientos de conformidad), y L<Unicode Technical Report #36, "Unicode Security Considerations"|http://www.unicode.org/reports/tr36/#Substituting_for_Ill_Formed_Subsequences>)."

=back

Se hizo este cambio porque se encontró que diversas herramientas comerciales, como los editores, o por cosas como control de código fuente, se habían escrito de modo que no podrían manejar archivos de programa que usasen estos puntos de código, ¡impidiendo su uso casi de forma irreversible!  Y esto nunca fue la intención.  La intención es que sirvieran para usarse dentro de una aplicación, o cooperando en un conjunto de aplicaciones.

Si está escribiendo código, como un editor, que se supone que es capaz de manejar datos de texto Unicode, entonces no debería usar estos puntos de código, pero en cambio, sí permitirles a la entrada.  Si necesita centinelas, deberían ser algo que no fuera Unicode legal.
Para datos UTF-8, puede usar los bytes 0xC1 y 0xC2 como centinelas, ya que nunca aparecen en un UTF-8 bien formado.  (Existen equivalentes para UTF-EBCDIC).  También puede almacenar sus puntos de código Unicode en variables enteras y usar valores negativos como centinelas.

Si no está escribiendo una herramienta así, entonces depende de usted si acepta o no esos no-caracteres como entrada (aunque el estándar no lo recomienda).  Si hace una comprobación estricta del flujo de entrada con Perl, estos puntos de código siguen estando prohibidos.  Esto se hace para mantener la compatibilidad con lo anterior (de otra forma, aparecerían potenciales agujeros de seguridad, como una aplicación nada sospechosa que se escribió asumiendo que los no-caracteres serían filtrados antes de obtenerlos, podría ahora, sin advertir, empezar a hacerlo).  Para hacer una comprobación estricta, puede usar la capa C<:encoding('UTF-8')>.

Perl continúa advirtiendo (usando la categoría de advertencias C<"nonchar">, que es una subcategoría de C<"utf8">) si se intenta sacar no-caracteres.

=head2 Más allá de los puntos de código Unicode

El mayor punto de código Unicode es C<U+10FFFF>, y Unicode solo define operaciones en los puntos de código hasta este.  Pero Perl trabaja en puntos de código hasta el número sin signo máximo permisible disponible en la plataforma.  Sin embargo, Perl no los aceptará desde los flujos de entrada a menos que se usen reglas laxas, y advertirá(usando la categoría de advertencias C<"non_unicode">, que es una subcategoría de C<"utf8">) si alguno sale al exterior.

Ya que las reglas Unicode no están definidas en estos puntos de código, si se aplica en ellos una operación definida en Unicode, Perl usa lo que creemos que son reglas sensibles, mientras que, generalmente, lo advertirá, usando la categoría C<"non_unicode">.  Por ejemplo, C<uc("\x{11_0000}")> generará tal advertencia, devolviendo como resultado el parámetro de entrada, ya que Perl define la mayúscula de cada punto de código no-Unicode como el propio punto de código.  (Todas las operaciones de cambio de caja, no solo las de poner en mayúscula, trabajan de esta forma).

La situación con las propiedades de coincidencia Unicode en expresiones regulares, las construcciones C<\p{}> y C<\P{}>, aplicadas a estos puntos de código, no está clara, y el cómo son manejadas ha cambiado a medida de que hemos ganado experiencia.

Una posibilidad es el de trata cualquier coincidencia contra estos puntos de código como algo indefinido.  Pero ya que Perl no tiene el concepto de indefinición en una coincidencia, le convierte en un fallo o un C<FALSE>.  Esto es casi, pero no todo, lo que Perl hacía a partir de v5.14 (cuando el uso de estos puntos de código se hacía de forma fiable) hasta v5.18.  La diferencia es que Perl trataba a todas las coincidencias C<\p{}> como fallo, mientras que a todas las coincidencias C<\P{}> como éxito.

Un problema con esto es que, en algunos casos, lleva a resultados inesperados y confusos:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fallaba en <= v5.18
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # ¡Fallaba! en <= v5.18

Es decir, trataba a ambas coincidencias como indefinidas, y las convertía a falso (levantando una advertencia en cada una de ellas).  El primer caso es el resultado esperado, pero el segundo es algo no intuitivo: "¿Cómo podría ser falso cuando son complementarios?" Otro problema fue que la implementación optimizó muchas propiedades de coincidencias Unicode a operaciones más simples y rápidas, que no levantaban la advertencia.  Elegimos no pasar por alto estas optimizaciones, que ayuda en la vasta mayor parte de las coincidencias, para justo generar una advertencia para el improbable caso de que se haga coincidir con un punto de código por encima de Unicode.

Como resultado de estos problemas, a partir de v5.20, lo que Perl hace es tratar a los puntos de código no Unicode simplemente como típicos caracteres Unicode sin asignar, y la coincidencia funciona.  (Nota: Unicode tiene atípicos puntos de código sin asignar.  Por ejemplo, tiene puntos de código de no-caracteres, los cuales, cuando se les asigne, se destinarán para la escritura Derecha-a-izquierda, como el Arábigo y el Hebreo.  Perl asume que no hay ningún punto de código con propiedades atípicas).

Perl, en la mayor parte de los casos, levantará una advertencia cuando busque un punto de código por encima del Unicode en una propiedad Unicode cuando el resultado es C<TRUE> para C<\p{}> y C<FALSE> para C<\P{}>.  Por ejemplo:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Falla, sin advertencia
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Éxito, con advertencia

En estos dos ejemplos, el carácter ha buscar no es Unicode, así que Unicode no define cómo debería hacerlo.  Claramente, no es un dígito hex. ASCII, así que el primer ejemplo debe fallar, y si lo hace, sin advertencia.  Pero es discutible que el segundo ejemplo debería ser indefinido, y por ello, resultar en un C<FALSE>.  Así que se levanta una advertencia.

Por ello la advertencia se levanta para menos casos que en Perl anteriores, y solo cuando el resultado sea discutible.  Resulta que ninguna de las optimizaciones hechas por Perl (o probablemente nunca hechas) hacen que se salte la advertencia, así que resuelve los dos primeros problemas de Perl.  La propiedad que más se utiliza que queda afectada por este cambio es C<\p{Unassigned}> que es la forma corta de C<\p{General_Category=Unassigned}>.  A partir de v5.20, todos los puntos de código no Unicode se consideran que son C<Unassigned>.  En versiones anteriores la coincidencia fallaba porque el resultado se consideraba que era indefinido.

El único lugar donde la advertencia no se levantaba es cuando, después de aplicar las optimizaciones, provocaban que ni siquiera se intentara probar todo el patrón.  Por ejemplo, Perl puede figurarse que para que coincida una cadena con un cierto patrón de expresiones regulares, la cadena tiene que contener la subcadena C<"foobar">.  Antes de intentar la coincidencia, Perl puede buscar esa subcadena, y si no la encuentra, falla inmediatamente la coincidencia sin realmente intentarla; así que no se generan advertencias incluso si la cadena contiene un punto de código por encima de Unicode.

Este comportamiento es como el "Haz lo que digo" de los primeros Perl, para la mayor parte de las aplicaciones.  Pero caza menos problemas con el código que necesita ser estrictamente cumplidor con Unicode.  Por tanto, hay disponible un modo adicional para acomodar tal código.  Este modo se activa si se compila un patrón de expresiones regulares dentro del ámbito léxico donde se hace fatal la clase de advertencias C<"non_unicode">, de esta manera:

 use warnings FATAL => "non_unicode"

(vea L<warnings>).  En este modo de operación, Pero levantará la advertencia para todas las coincidencias contra puntos de código no Unicode (no solo los discutibles), e impide las optimizaciones que podrían hacer que no se emita una advertencia.  (Actualmente, sigue sin avisar si la coincidencia ni siquiera se intenta, como en el ejemplo anterior del C<"foobar">).

En resumen, Perl trata ahora de forma normal, a los puntos de código no Unicode como puntos de código Unicode sin asignar, para las coincidencias de expresiones regulares, levantando una advertencia solo cuando el resultado sea discutible.  Aún así, si la advertencia se hace fatal, no se obvia.

Hay una excepción para todo esto.  C<\p{All}> se parece a una propiedad Unicode, pero es una extensión Perl que se define como cierta para todos los puntos de código posibles, Unicode o no, así que no se genera ninguna advertencia cuando se busque una coincidencia contra un punto de código no Unicode.  (Antes de v5.20, era un sinónimo exacto para C<\p{Any}>, coincidiendo con puntos de código del C<0>
al C<0x10FFFF>).

=head2 Implicaciones de seguridad de Unicode

Primero, lea L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.

También tenga en cuenta lo siguiente:

=over 4

=item *

UTF-8 mal formado

Desafortunadamente, la especificación original de UTF-8 deja algún espacio para la interpretación de cuántos bytes de la salida codificada debería generarse a partir de un único carácter Unicode a la entrada.  Estrictamente hablando, se debería generar la secuencia más corta de bytes UTF-8, porque si no, existe la posibilidad de un desbordamiento en el búfer de entrada al recibir el final de una conexión UTF-8.  Perl siempre genera la longitud más corta de UTF-8, y con las advertencias activadas, Perl avisará sobre longitudes de UTF-8 no cortas, junto con otras malformaciones, como los sustitutos, que no son puntos de código Unicode válidos para el intercambio.

=item *

La coincidencia de patrones de expresiones regulares le puede sorprender su no está acostumbrado a Unicode.  A partir de Perl 5.14, están disponibles diversos modificadores de patrón para controlar esto, llamados el conjunto de caracteres de modificadores.  Los detalles se dan en L<perlre/Conjunto de caracteres de modificadores>.

=back

Como se ha dicho antes, Perl tiene un pie (¿dos hooves?) plantado en un mundo distinto: el viejo mundo del ASCII y las localizaciones de un solo byte, y el nuevo mundo de Unicode, actualizando cuando es necesario.
Si el código que ha heredado no usa Unicode de forma explícita, no ocurre un cambio automático a Unicode.

=head2 Unicode en Perl para EBCDIC

Unicode se soporta en plataformas EBCDIC.  Vea L<perlebcdic>.

A menos que se indiquen específicamente los problemas entre ASCII y EBCDIC, las referencias a la codificación UTF-8 en este documento y el resto se debería leer como que nos referimos a UTF-EBCDIC en plataformas EBCDIC.
Vea L<perlebcdic/Unicode y UTF>.

Debido a que UTF-EBCDIC es tan similar a UTF-8, las diferencias están, en su mayor parte, escondidas; S<C<use utf8>> (y NO algo como S<C<use utfebcdic>>) declara que el script está en la codificación Unicode de 8 bit "nativa" de la plataforma.  (De modo parecido para la capa C<":utf8">).

=head2 Locales

Vea L<perllocale/Unicode y UTF-8>

=head2 Cuando Unicode no hace lo que queremos

Existen muchos lugares donde Unicode (en alguna codificación o cualquier otra) se podrían indicar como argumentos o recibirlos como resultados, o ambos, en Perl, pero no es así, a pesar de Perl tiene muchas maneras de sacar o recibir Unicode, y unos pocos "puntos de entrada" como el array C<@ARGV> (que algunas veces se interpretan como UTF-8).

Lo siguiente son tales interfaces.  También, vea L</El "Error de Unicode">.
Para todas estas interfaces, actualmente, Perl (hasta v5.16.0) simplemente asume cadenas de bytes tanto en los argumentos como en los resultados, o cadenas UTF-8 si se usa el (obsoleto) I<pragma> C<encoding>.

Una razón por la que Perl no intenta resolver el rol de Unicode en estas situaciones es que las respuestas son altamente dependientes del sistema operativo y el sistema de archivo(s).  Por ejemplo, entre que los nombres de los archivos pueden estar en Unicode y exactamente qué clase de codificación, no es exactamente un concepto portable.  De forma similar para C<qx> y C<system>: ¿cómo de bien "el interfaz de la línea de comandos" (¿y cuál de ellas?) manejará Unicode?

=over 4

=item *

C<chdir>, C<chmod>, C<chown>, C<chroot>, C<exec>, C<link>, C<lstat>, C<mkdir>,
C<rename>, C<rmdir>, C<stat>, C<symlink>, C<truncate>, C<unlink>, C<utime>, C<-X>

=item *

C<%ENV>

=item *

C<glob> (o sea, el C<E<lt>*E<gt>>)

=item *

C<open>, C<opendir>, C<sysopen>

=item *

C<qx> (o sea, el operador comilla invertida), C<system>

=item *

C<readdir>, C<readlink>

=back

=head2 El "Error de Unicode"

El término "I<bug Unicode>" (error Unicode) se ha aplicado a una inconsistencia con los puntos de código en el bloque C<Latin-1 Supplement>, esto es, entre 128 y 255.  Si no se especifica una localización, a diferencia de todos los demás caracteres o puntos de código, estos caracteres pueden tener muchas semánticas diferentes dependiendo de las reglas que están en activo.  (Los caracteres cuyos puntos de código están por encima del 255 fuerza las reglas Unicode; mientras tanto, las reglas para los caracteres ASCII son las mismas tanto para las reglas ASCII como Unicode).

Bajo las reglas Unicode, estos caracteres por encima del Latin1 se interpretan como puntos de código Unicode, que significa que tienen la misma semántica que Latin-1 (ISO-8859-1) y los controles C1.

Como se ha explicado en L</Reglas ASCII contra reglas Unicode>, bajo las reglas ASCII, se consideran que son caracteres sin asignar.

Esto puede llevar a resultados inesperados.  Por ejemplo, la semántica de una cadena puede cambiar de repente si se le añade un punto de código por encima del 255, que cambia las reglas de ASCII a Unicode.  Como un ejemplo, considere el siguiente programa y su salida:

 $ perl -le'
     no feature 'unicode_strings';
     $s1 = "\xC2";
     $s2 = "\x{2660}";
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1

Si no existe ningún C<\w> en C<s1> ni en C<s2>, ¿por qué tiene una la concatenación?

Esta anomalía se enraíza en los intentos de Perl de no perturbar a los programas más viejos que no usan Unicode, junto con el deseo de Perl de añadir suavemente el soporte de Unicode.  Pero el resultado giró a algo no tan suave.  (Por cierto, puede elegir el recibir una advertencia cuando sucedan cosas como esta.  Vea C<L<encoding::warnings>>).

Se añadió L<S<C<use feature 'unicode_strings'>>|feature/La característica 'unicode_strings'> a partir de Perl v5.12, para arreglar el problema.  Afecta a estas cosas:

=over 4

=item *

Cambiando el tamaño de caja de un escalar, esto es, usar C<uc()>, C<ucfirst()>, C<lc()> y C<lcfirst()>, o C<\L>, C<\U>, C<\u> y C<\l> en contextos de doble entrecomillado, como las sustituciones en expresiones regulares.

Bajo C<unicode_strings>, a partir de Perl 5.12.0, se usan de forma general las reglas Unicode.  Vea L<perlfunc/lc> para detalles de cómo funciona esto en combinación con otros I<pragmas>.

=item *

Usando coincidencias independientes del tamaño de caja (C</i>) en expresiones regulares.

A partir de Perl 5.14.0, las expresiones regulares compiladas dentro del ámbito de C<unicode_strings> usan las reglas Unicode incluso cuando se ejecutan o compilan en expresiones regulares más grandes fuera del contexto.

=item *

Coincidir con cualquiera de las muchas propiedades en expresiones regulares.

Estas propiedades son C<\b> (sin llaves), C<\B> (sin llaves), C<\s>, C<\S>, C<\w>, C<\W>, y todas las clases de carácter Posix I<excepto> C<[[:ascii:]]>.

A partir de Perl 5.14.0, las expresiones regulares compiladas dentro del ámbito de C<unicode_strings> usan las reglas Unicode incluso cuando se ejecutan o compilan en expresiones regulares más grandes fuera del contexto.

=item *

En C<quotemeta> o en su equivalente en línea C<\Q>.

A partir de Perl 5.16.0, se usan reglas de escapado consistentes con el ámbito de C<unicode_strings>, como se describe en L<perlfunc/quotemeta>.
Antes de eso, o fuera de su ámbito, no se escapa ningún punto de código por encima del 127 en las cadenas codificadas en UTF-8, pero en cadenas codificadas en bytes, los puntos de código entre 128-255 siempre se escapan.

=back

Por lo que ha visto hasta ahora, el efecto de C<unicode_strings> se incrementa a medida que salen nuevas versiones de Perl.  (Y el soporte de Unicode en Perl sigue mejorando; es mejor usar la última distribución disponible para obtener los resultados más completos y precisos como sea posible).  Note que C<unicode_strings> se elige automáticamente si usa S<C<use 5.012>> o superior.

Para Perl anteriores que los descrito antes, o cuando se pase una cadena a una función fuera del ámbito de C<unicode_strings>, vea la siguiente sección.

=head2 Forzar Unicode en Perl (o no forzar Unicode en Perl)

Algunas veces (vea L</"Cuando Unicode no hace lo que queremos"> o L</El "Error de Unicode">) existen situaciones donde, simplemente, necesita forzar que una cadena de bytes se convierta en UTF-8, o viceversa.  El módulo estándar L<Encode> se puede usar para esto, o las llamadas de bajo nivel L<C<utf8::upgrade($bytestring)>|utf8/Funciones de utilidad> y L<C<utf8::downgrade($utf8string[, FAIL_OK])>|utf8/Funciones de utilidad>.

Note que C<utf8::downgrade()> puede fallar si la cadena contiene caracteres que no encajan en un byte.

Llamar a cualquier función en una cadena que ya está en el estado deseado se convierte en una no-operación.

L</Reglas ASCII contra reglas Unicode> da todas las formas en que una cadena debe cumplir las reglas Unicode.

=head2 Usar Unicode en XS

Vea L<perlguts/"Soporte Unicode"> para una introducción a Unicode a nivel de XS, y L<perlapi/Soporte Unicode> para los detalles de la API.

=head2 Hackear Perl para que trabaje con versiones anteriores de Unicode (solo para hackers muy serios)

Perl, por defecto, viene con soporte incluido para la última versión de Unicode, pero la meta es permitirle cambiar y usar cualquier otra versión anterior.  En Perl v5.20 y v5.22, sin embargo, la versión más vieja utilizable es Unicode 5.1.
Perl v5.18 es capaz de manejar todas las versiones anteriores.

Descargue los archivos de la versión deseada de Unicode del sitio web de Unicode L<http://www.unicode.org>).  Deberían reemplazar los archivos existentes en F<lib/unicore> en el árbol de código fuente de Perl.  Siga las instrucciones en F<README.perl> en ese directorio para cambiar algunos nombres, y entonces compile perl (vea L<INSTALL>).

=head2 Portar código desde perl-5.6.X

Versiones de Perl a partir de 5.8 tienen un modelo diferente de Unicode que el de 5.6. En 5.6 se requería que el programador usase el I<pragma> C<utf8> para declarar que en un ámbito dado se esperaba que se gestionarán datos Unicode, y asegurarse que esos datos Unicode quedaban en ese ámbito. Si tiene código que trabaja en 5.6, necesitará hacer alguno de los siguientes ajustes. Los ejemplos se escriben de tal forma que el código seguirá trabajando bajo 5.6, así que puede probarlos con seguridad.

=over 3

=item *

Un identificador de archivo que lea o escriba UTF-8

  if ($] > 5.008) {
    binmode $fh, ":encoding(utf8)";
  }

=item *

Un escalar que se va a pasar a alguna extensión

Bien sea C<Compress::Zlib>, C<Apache::Request> o cualquier extensión que no mencione Unicode en su página de manual, necesita asegurarse que el indicador UTF8 esté desactivado. Note que en el momento de escribir esto (enero de 2012) los módulos mencionados no son compatibles con UTF-8. Por favor, compruebe la documentación para verificar si esto sigue siendo verdad.

  if ($] > 5.008) {
    require Encode;
    $val = Encode::encode_utf8($val); # hace octetos
  }

=item *

Un escalar que obtenemos de una extensión

Si cree que el escalar que recibe está en UTF-8, lo más probable es que quiera reestablecer el indicador UTF8:

  if ($] > 5.008) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }

=item *

Lo mismo, si realmente está seguro de que es UTF-8

  if ($] > 5.008) {
    require Encode;
    Encode::_utf8_on($val);
  }

=item *

Un envoltorio para L<DBI> C<fetchrow_array> y C<fetchrow_hashref>

Cuando la base de datos solo contiene UTF-8, es conveniente una función o método que reemplace a todas sus llamadas a C<fetchrow_array> y C<fetchrow_hashref>. Un envoltorio de función hará también más fácil adaptar futuras mejoras a su controlador de base de datos. Note que en el momento de escribir esto (enero de 2012), DBI no tiene una forma estandarizada de tratar datos UTF-8. Por favor, compruebe la (documentación) L<DBI documentation|DBI> para verificar si esto sigue siendo verdad.

  sub fetchrow {
    # $what es una de las fetchrow_{array,hashref}
    my($self, $sth, $what) = @_;
    if ($] < 5.008) {
      return $sth->$what;
    } else {
      require Encode;
      if (wantarray) {
        my @arr = $sth->$what;
        for (@arr) {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_);
        }
        return @arr;
      } else {
        my $ret = $sth->$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined
            && /[^\000-\177]/
            && Encode::_utf8_on($_) for $ret->{$k};
          }
          return $ret;
        } else {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }


=item *

Un escalar muy grande que sabe que solo contiene ASCII

Escalares que solo contienen ASCII y que se marcan como UTF-8 son algunas veces un peso para su programa. Si reconoce tal situación, simplemente quite el indicador UTF8:

  utf8::downgrade($val) if $] > 5.008;

=back

=head1 ERRORES

Vea también L</El "Error de Unicode"> más arriba.

=head2 Interacción con extensiones

Cuando Perl intercambia datos con una extensión, ésta debería ser capaz de entender el indicador UTF8 y actuar consiguientemente. Si la extensión no reconoce este indicador, es muy posible que la extensión devolverá datos con el indicador puesto de forma incorrecta.

Así que si está trabajando con datos Unicode, consulte la documentación de cada módulo que está usando si existe cualquier problema con el intercambio de datos Unicode. Si la documentación no dice nada en absoluto sobre Unicode, sospeche lo peor y eche un vistazo al código fuente del módulo para aprender cómo está implementado. Los módulos escritos completamente en Perl no deberían dar problemas. Módulos que, directa o indirectamente acceden a código escrito en otros lenguajes de programación, son un riesgo.

Para funciones afectadas, la estrategia más simple para evitar la corrupción de datos es siempre codificar el intercambio de datos de forma explícita. Elija una codificación que sepa que su extensión pueda manejar. Convierta los argumentos pasados a la extensión a esa codificación y convierta de esa codificación los resultados obtenidos. Escriba funciones envoltorio que hagan la conversión por usted, así luego puede cambiar las funciones cuando la extensión sepa hacerlo.

Por dar un ejemplo, vemos que la popular función C<Foo::Bar::escape_html> aún no trata datos Unicode. La función envoltorio convierte el argumento a UTF-8 crudo y convierte el resultado devuelto a la representación interna de Perl como:

    sub my_escape_html ($) {
        my($what) = shift;
        return unless defined $what;
        Encode::decode_utf8(Foo::Bar::escape_html(
                                         Encode::encode_utf8($what)));
    }

Algunas veces, cuando la extensión no convierte los datos pero solo los almacena o recupera, puede usar la, por lo contrario, peligrosa función L<C<Encode::_utf8_on()>|Encode/_utf8_on>. Supongamos que extensión popular C<Foo::Bar>, escrita en C, proporciona un método C<param> que le permite almacenar o recuperar datos de acuerdo a estos prototipos:

    $self->param($name, $value);            # establece un escalar
    $value = $self->param($name);           # recupere un escalar

Si aún no proporciona soporta para ninguna codificación, uno podría escribir una clase derivada con tal método C<param>:

    sub param {
      my($self,$name,$value) = @_;
      utf8::upgrade($name);     # aseguramos que está codificado en UTF-8
      if (defined $value) {
        utf8::upgrade($value);  # aseguramos que está codificado en UTF-8
        return $self->SUPER::param($name,$value);
      } else {
        my $ret = $self->SUPER::param($name);
        Encode::_utf8_on($ret); # lo sabemos, está codificado en UTF-8
        return $ret;
      }
    }

Algunas extensiones proporcionan filtros en puntos de datos de entrada/salida, como C<DB_File::filter_store_key> y familia. Busque esos filtros en la documentación de su extensión; pueden hacerle mucho más fácil la transición a los datos Unicode.

=head2 Velocidad

Algunas funciones son más lentas cuando trabajan con cadenas codificadas en UTF-8 que cuando son cadenas codificadas en bytes.  Todas las funciones que necesitan manejar caracteres, como C<length()>, C<substr()> o C<index()>, o coincidencias en expresiones regulares, pueden trabajar B<mucho> más rápido cuando los datos subyacentes están codificados en bytes.

En Perl 5.8.0 la lentitud a menudo era muy espectacular; en Perl 5.8.1 se presentó un esquema de cacheo que mejoraba la situación.  En general, las operaciones con cadenas codificadas en UTF-8 siguen siendo más lentas. Como ejemplo, las propiedades Unicode (clases de carácter) como C<\p{Nd}> se sabe que son bastante más lentas (5 a 20 veces) que sus homólogas como C<[0-9]> (de nuevo, existen centenares de caracteres Unicode que coinciden con C<Nd> comparado con los 10 caracteres ASCII que coinciden con C<[0-9]>).

=head1 VEA TAMBIÉN

L<perlunitut>, L<perluniintro>, L<perluniprops>, L<Encode>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlvar/"${^UNICODE}">,
L<http://www.unicode.org/reports/tr44>).

=cut
