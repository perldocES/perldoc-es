=head1 NAME

perlport - Guía de portabilidad

=head1 DESCRIPCIÓN

Perl se ejecuta en numerosos sistemas operativos.  Mientras que la mayor parte comparte mucho en común, también tienen sus propias características únicas.

Este documento está para ayudarle a encontrar qué constituye código Perl portable.  De esa manera, una vez que tome una decisión para escribir de forma portable, sabe dónde estarán los límites y mantenerse dentro de ellos.

Hay un toma y daca entre aprovecharse de un particular tipo de ordenador y aprovecharse de un rango de ellos.
Naturalmente, a medida que amplía su rango y se vuelve más diverso, caen los factores comunes, y usted queda con una cada vez más pequeña área de terreno común en que puede operar para cumplir con una tarea particular.  Así, cuando comienza a atacar un problema, es importante considerar bajo qué parte de la curva quiere operar.  Específicamente, debe decidir si es importante que la tarea que está codificando contempla la portabilidad generalizada, o si solo lo suficiente para tener el trabajo hecho.
Esta es la elección más difícil de hacer.  El resto es sencillo, porque Perl proporciona muchas elecciones, cualquiera que sea la forma de aproximarse al problema.

Mirándolo de otra manera, escribir código portable es, normalmente algo que limita sus elecciones disponibles.  Naturalmente, necesita disciplina y sacrificio para hacerlo así.  El producto de la portabilidad y la conveniencia puede ser una constante.  Queda advertido.

Sea consciente de dos puntos importantes:

=over 4

=item No todos los programas Perl tienen que ser portables

No hay ninguna razón por la que no debería usar Perl como lenguaje para unir herramientas Unix, o prototipar una aplicación Macintosh, o gestionar el registro de Windows.  Si no tiene sentido que sea portable, por una u otra razón en un determinado programa, entonces no hay por qué molestarse.

=item Casi todo lo de Perl ya I<es> portable

No sea necio pensando que es difícil crear código Perl portable.  No lo es.  Perl intenta nivelar el espacio que hay entre lo que está disponible en las diferentes plataformas, y todos los medios disponibles para usar esas características.  Así casi todo el código Perl corre en cualquier máquina sin modificación.  Pero hay algunos asuntos significativos escribiendo código portable, y este documento se dedica enteramente a esos asuntos.

=back

Aquí está la regla general: Cuando tenga que hacer una tarea que se suela hacer en un amplio rango de plataformas, piense en escribir código portable.  De esa manera, no sacrifica en exceso la forma de elegir qué implementaciones usar, y al mismo tiempo le da a los usuarios muchas más elecciones de plataformas.  De otra manera, cuando tenga que aprovecharse de alguna característica única de una determinada plataforma, como sucede a menudo en programación de sistemas (sea para Unix, Windows, VMS, etc.), considere escribir código específico de la plataforma.

Cuando el código se vaya a ejecutar solo en dos o tres sistemas operativos, quizás necesite considerar solo las diferencias de esos sistemas particulares.
Lo importante es decidir dónde se ejecutará el código y deliberar su decisión.

El material que sigue está separado en tres secciones: cuestiones principales de portabilidad (L<"CUESTIONES">), cuestiones específicas de la plataforma (L<"PLATAFORMAS">), y funciones Perl incorporadas que se comportan de forma diferente en algunas adaptaciones (L<"IMPLEMENTACIONES DE FUNCIONES">).

Esta información no debería considerarse completa; incluye posiblemente información transitoria sobre las idiosincrasias de algunas adaptaciones, casi todo ello en un estado de constante evolución.  Así, este material debería considerarse un trabajo perpetuamente en progreso (C<< <IMG SRC="yellow_sign.gif" ALT="Under Construction"> >>).

=head1 CUESTIONES

=head2 Finales de línea

En la mayor parte de los sistemas operativos, las líneas en los archivos terminan con caracteres de fin de línea.
Es justo lo que se usa como fin de línea lo que puede variar de un SO a otro.  Unix, tradicionalmente usa C<\012>, los del tipo DOS usa C<\015\012>, S<Mac OS> usa C<\015>, y z/OS usa C<\025>.

Perl usa C<\n> para representar el fin de línea "lógico", donde lo que es lógico puede depender de la plataforma en uso.  En MacPerl, C<\n> siempre significa C<\015>.  En plataformas EBCDIC, C<\n> podría ser C<\025> o C<\045>.
En Perl bajo DOS, C<\n> significa normalmente C<\012>, pero cuando se accede a un archivo en modo "texto", perl usa la capa C<:crlf> que lo traduce a (o desde) C<\015\012>, dependiendo de si está leyendo o escribiendo. Unix hace lo mismo en las tty en modo canónico.  C<\015\012> se refiere generalmente a CRLF.

Para recortar los finales de línea de las líneas de texto, use C<chomp()>.  Con las opciones por defecto esa función busca por un carácter C<\n> final y lo recorta de una forma portable.

Cuando trata con archivos binarios (o archivos de texto en modo binario) asegúrese de establecer explícitamente C<$/> al valor apropiado para su formato de archivo antes de usar C<chomp()>.

Debido a la traducción del modo "texto", los perl en DOS tienen limitaciones al usar C<seek> y C<tell> en un archivo accedido en modo "texto".
Aférrese a buscar (C<seek>) en posiciones que obtiene desde C<tell> (y no otros), y podrá usar libremente C<seek> y C<tell> incluso en modo "texto".  Usar C<seek> o C<tell> u otras operaciones de archivo puede que no sea portable.  Si usa C<binmode> en un archivo, sin embargo, puede usar de forma segura C<seek> y C<tell> con valores arbitrarios.

Un concepto erróneo en programación de I<socket> es que siempre S<C<\n eq \012>>.  Cuando use protocolos tales como protocolos normales de Internet, C<\012> y C<\015> se deben indicar específicamente, y los valores lógicos de C<\n> y C<\r> (retorno de carro) no son fiables.

    print SOCKET "¡Hola, cliente!\r\n";        # INCORRECTO
    print SOCKET "¡Hola, cliente!\015\012";    # CORRECTO

Aun así, usar C<\015\012> (o C<\cM\cJ> o C<\x0D\x0A>) puede ser tedioso y feo, así como confuso a los que mantengan el código.  Por ello, el módulo C<Socket> suministra la Solución Correcta para quienes la quieran usar.

    use Socket qw(:DEFAULT :crlf);
    print SOCKET "¡Hola, cliente!$CRLF"        # CORRECTO

Cuando lea de un I<socket>, recuerde que el separador por defecto de registros de entrada C<$/> es C<\n>, pero código I<socket> robusto reconocerá tanto C<\012> o C<\015\012> como fin de línea:

    while (<SOCKET>) {  # ¡NO ACONSEJABLE!
        # ...
    }

Ya que CRLF y LF terminan en LF, el separador de registro de entrada se puede establecer a LF y filtrar más tarde los CR.  Mejor escribirlo así:

    use Socket qw(:DEFAULT :crlf);
    local($/) = LF;      # no necesario si $/ ya es \012

    while (<SOCKET>) {
        s/$CR?$LF/\n/;   # no es seguro si socket usa LF o CRLF
    #   s/\015?\012/\n/; # lo mismo
    }

Se prefiere este ejemplo sobre el anterior -incluso para plataformas Unix- porque ahora se filtran todos los C<\015> (C<\cM>).

De modo parecido, las funciones que devuelve datos de texto -tales como una función que lee una página web- deberían algunas veces traducir los caracteres de nueva línea antes de devolver los datos, si no han sido traducidos a la representación local de los caracteres de nueva línea.  Bastará a menudo con una única línea de código:

    $datos =~ s/\015?\012/\n/g;
    return $datos;

Algunos de estos pueden confundir.  Aquí hay una referencia útil de los caracteres ASCII CR y LF.  Puede imprimirla y pegarla en su billetera.

    LF  eq  \012  eq  \x0A  eq  \cJ  eq  chr(10)  eq  ASCII 10
    CR  eq  \015  eq  \x0D  eq  \cM  eq  chr(13)  eq  ASCII 13

             | Unix | DOS  | Mac  |
        ---------------------------
        \n   |  LF  |  LF  |  CR  |
        \r   |  CR  |  CR  |  LF  |
        \n * |  LF  | CRLF |  CR  |
        \r * |  CR  |  CR  |  LF  |
        ---------------------------
        * modo texto en STDIO

La columna Unix asume que no está accediendo a una línea serie (como una tty) en modo canónico.  Si sí está, entonces CR  a la entrada se convierte en "\n", y "\n" a la salida se convierte en CRLF.

Estas son las definiciones más comunes de C<\n> y C<\r> en Perl.
Pueden existir otras.  Por ejemplo, en una implementación EBCDIC tales como z/OS (OS/390) o OS/400 (usando el ILE, PASE está basado en ASCII) el material anterior es similar a "Unix" pero los números de código cambian:

    LF  eq  \025  eq  \x15  eq  \cU  eq  chr(21)  eq  CP-1047 21
    LF  eq  \045  eq  \x25  eq           chr(37)  eq  CP-0037 37
    CR  eq  \015  eq  \x0D  eq  \cM  eq  chr(13)  eq  CP-1047 13
    CR  eq  \015  eq  \x0D  eq  \cM  eq  chr(13)  eq  CP-0037 13

             | z/OS | OS/400 |
        ----------------------
        \n   |  LF  |  LF    |
        \r   |  CR  |  CR    |
        \n * |  LF  |  LF    |
        \r * |  CR  |  CR    |
        ----------------------
        * modo texto en STDIO

=head2 Anchos y disposiciones de los pesos de los números

CPU diferentes almacenan enteros y números de punto flotante en orden (llamado I<endianness>) y anchos (siendo 32 y 64 bit lo más común hoy en día) diferente.  Esto afecta a sus programas cuando intentan transferir números en formato binario de una arquitectura CPU a otra, normalmente tanto en conexiones de red "activas", como almacenando los números en un almacenamiento secundario tal como un archivo en disco o cinta.

Confundir el orden de almacenamiento crea un enredo de los números.  Si un servidor I<little-endian> (Intel, VAX) almacena 0x12345678 (305419896 en decimal), un servidor I<big-endian> (Motorola, Sparc, PA) lo lee como 0x78563412 (2018915346 en decimal).  Alpha y MIPS pueden ser: Digital/Compaq utilizados (bueno, usados) en modo I<little-endian>; SGI/Cray los usa en modo I<big-endian>.  Para evitar este problema en conexiones de red (I<socket>) use los formatos de C<pack> y C<unpack> C<n> y C<N>, las distintas órdenes de "I<network>" (red).  Se garantiza que son portables.

A partir de Perl 5.10.0, puede también usar los modificadores C<E<gt>> y C<E<lt>> para forzar el orden de los bytes I<big-> o I<little-endian>.  Esto es útil si quiere almacenar enteros con signo o enteros de 64 bit, por ejemplo.

Puede explorar la I<endianness> de su plataforma desempaquetando una estructura de datos empaquetados en un formato nativo tal como:

    print unpack("h*", pack("s2", 1, 2)), "\n";
    # '10002000' en, p.e. Intel x86 o Alpha 21064 en modo little-endian
    # '00100020' en, p.e. Motorola 68040

Si necesita distinguir entre arquitecturas I<endian> podría usar cualesquiera de las variables establecidas así:

    $is_big_endian    = unpack("h*", pack("s", 1)) =~ /01/;
    $is_little_endian = unpack("h*", pack("s", 1)) =~ /^1/;

Anchos diferentes pueden causar truncamiento incluso entre plataformas de igual I<endianness>.  La plataforma con el ancho más corto pierde las partes altas del número.  No hay una buena solución para este problema excepto evitar transferir o almacenar números binarios en crudo.

Uno puede solventar estos dos problemas de dos formas.  Tanto la transferencia y almacenamiento de números siempre en formato texto, en lugar de binario en crudo, o considerar usar módulos como C<Data::Dumper> y C<Storable> (incluido a partir de Perl 5.8).  Mantener todos los datos como texto simplifica significativamente el problema.

=head2 Archivos y sistemas de archivos

La mayor parte de las plataformas modernas estructuran los archivos de forma jerárquica.
Así, es razonablemente seguro asumir que todas las plataformas soportan la noción de "ruta" para identificar de forma única un archivo en el sistema.  Aún así, la forma en que está escrita la ruta, difiere considerablemente.

Aunque similares, las especificaciones de la ruta de archivos difieren entre Unix, Windows, S<Mac OS>, OS/2, VMS, VOS, S<RISC OS>, y probablemente otros.
Unix, por ejemplo, es uno de los pocos SO que tiene la elegante idea de un único directorio raíz.

DOS, OS/2, VMS, VOS y Windows pueden trabajar de forma similar a Unix con el C</> como separador, o en su propias idiosincrásicas maneras (tales como tener varios directorios raíz y varios archivos "sin raíz" tales como NIL: y LPT:).

S<Mac OS> 9 y anteriores usaban C<:> como separador de ruta en lugar de C</>.

El sistema de archivos no soporta enlaces duros (C<link>) no simbólicos (C<symlink>, C<readlink>, C<lstat>).

El sistema de archivos no puede soportar tiempos de acceso ni tiempos de cambio (significando que el único tiempo portable es el tiempo de modificación), o la granularidad de un segundo de cualquiera de los tiempos (p.e. el sistema de FAT limita la granularidad a dos segundos).

El "tiempo de cambio de inodo" (el test de archivo C<-C>) puede ser realmente el "tiempo de creación" (que no está en Unix).

El perl de VOS puede emular los nombre de archivo con un separador C</>.  Los caracteres nativos de los nombres de las rutas, tales como mayor-que, menor-que, signo de número y signo de porcentaje, siempre se aceptan.

El perl S<RISC OS> puede emular nombres de archivo Unix como C</> como separador de ruta, o usar el nativo C<.>  para separador de ruta y C<:> para señalar sistemas de archivos y nombres de disco.

No asuma la semántica de acceso como los del sistema de archivos Unix: la lectura, escritura y ejecución son todos los permisos posibles, e incluso si existen, su semántica (por ejemplo, lo que significan C<"r">, C<"w"> y C<"x"> sobre un directorio) son los de Unix.  Las distintas capas de compatibilidad Unix/POSIX normalmente intentan hacer que funcionen interfaces como C<chmod()>, pero algunas veces no hay un buen mapeo.

Los módulos C<File::Spec> proporcionan métodos para manipular especificaciones de ruta y devuelven los resultados en formato nativo para cada plataforma.  Esto, a menudo, es innecesario ya que las rutas del estilo Unix los entiende Perl en todas las plataformas soportadas, pero si necesita producir rutas nativas para una utilidad nativa que no entiende la sintaxis Unix, o si está operando sobre rutas o componentes de rutas en una (posiblemente nativa) sintaxis desconocida, C<File::Spec> es su amigo.  Aquí hay dos breves ejemplos:

    use File::Spec::Functions;
    chdir(updir());        # subir un directorio

    # Concatenar una ruta a partir de sus componentes
    my $file = catfile(updir(), 'temp', 'file.txt');
    # en Unix:    '../temp/file.txt'
    # en Win32:   '..\temp\file.txt'
    # en VMS:     '[-.temp]file.txt'

En general, el código de producción no debería tener rutas a archivos de forma explícita.
Es mejor que los suministre el usuario o leídos desde un archivo de configuración, recordando que la sintaxis de la ruta de archivos varía en máquinas diferentes.

Esto es especialmente notable en I<scripts> como Makefile y baterías de pruebas, que a menudo asume C</> como separador de ruta para subdirectorios.

También el uso de C<File::Basename> de la distribución estándar, que divide una ruta en partes (nombre del archivo, ruta completa del directorio, y sufijo del archivo).

Incluso cuando esté en una única plataforma (si llama a Unix una única plataforma), recuerde no contar con la existencia o los contenidos de archivos o directorios específicos del sistema, como F</etc/passwd>, F</etc/sendmail.conf>, F</etc/resolv.conf> o incluso F</tmp/>.  Por ejemplo, F</etc/passwd> puede existir pero no contener las contraseñas codificadas, porque el sistema está usando alguna forma de seguridad mejorada.
O puede que no contenga todas las cuentas, porque el sistema está usando NIS.
Si el código necesita confiar en tal archivo, incluya una descripción del archivo y su formato en la documentación del código, y luego hacerle más sencillo para el usuario el modificar la posición por defecto del archivo.

No asuma que un archivo de texto termina con un carácter de nueva línea.  Deberían, pero las personas lo olvidan.

No tenga dos archivos o directorios con el mismo nombre con diferente tamaño de caja, como F<test.pl> y F<Test.pl>, ya que muchas plataformas son insensibles a ese tamaño (o al menos no lo tienen en cuenta).  También, intente no tener caracteres extraños (excepto C<.>) en los nombres, y mantenga la convención 8.3, para máxima portabilidad, aunque esto suponga una carga.

Así mismo, cuando use el módulo C<AutoSplit>, intente mantener sus funciones con la nomenclatura 8.3 y la convención insensible al tamaño de caja; o, al menos, haga que los archivos resultantes tengan los primeros ocho caracteres únicos.

El espacio en blanco en los nombre de archivo se tolera en muchos sistemas, pero no en todos, e incluso en sistemas donde podría tolerarse, algunas utilidades podrían quedarse confundidas con tal espacio en blanco.

En muchos sistemas (DOS, VMS ODS-2) no se puede tener más de un C<.> en los nombres de sus archivos.

No asuma que C<< > >> no pueda ser el primer carácter del nombre de un archivo.
Siempre use C<< < >> explícitamente para abrir un archivo en lectura, o incluso mejor, use la versión de tres argumentos de C<open>, a menos que quiera que el usuario sea capaz de especificar una tubería abierta.

    open my $fh, '<', $archivo_actual or die $!;

Si los nombres de archivo pudieran usar caracteres extraños, es más seguro abrirlo con C<sysopen> en lugar de C<open>.  C<open> es mágico y puede traducir caracteres como C<< > >>, C<< < >> y C<|>, que quizás no sea lo más correcto.  (Algunas veces, sin embargo, es lo correcto).
El open de tres argumentos también puede ayudar a protegerse contra esta traducción en casos donde sea indeseable.

No use C<:> como parte de un nombre de archivo ya que muchos sistemas lo usan para su propia semántica (Mac OS Classic para separar componentes en la ruta; muchos esquemas de red y utilidades para separar el nombre del nodo y la ruta, y así).  Por la misma razón, evite C<@>, C<;> y C<|>.

No asuma que en los nombres de ruta pueda colapsar dos barras diagonales juntas C<//> en una: algunos sistemas de archivos de red y I<clustering> tienen una semántica especial para ellos.  Permita que el sistema operativo se encargue de él.

Los I<caracteres portables de nombre de archivo> como se define por ANSI C son

 a b c d e f g h i j k l m n o p q r s t u v w x y z
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
 0 1 2 3 4 5 6 7 8 9
 . _ -

y el C<"-"> no debería ser el primer carácter.  Si quiere ser hipercorrecto, manténgase insensible al tamaño de caja y dentro de la convención de nombres 8.3 (todos los archivos y directorios tienen que ser únicos dentro de un directorio si sus nombres están en minúsculas y truncados a ocho caracteres antes del C<.>, si lo hay, y tres caracteres después del C<.>, si lo hay).  (Y no use C<.> en los nombres de directorio).

=head2 Interacción con el sistema

No todas las plataformas proporcionan una línea de comandos.  Normalmente son plataformas que confían principalmente en un I<Graphical User Interface> (GUI, Interfaz gráfico de usuario) para la interacción con el usuario.  Un programa que requiera un interfaz de línea de comandos podría no funcionar en todas partes.  Esto es algo que, probablemente debe gestionar el usuario del programa, así que no lo deje para el final.

Algunas plataformas no pueden borrar o renombrar archivos estando abiertos por el sistema; esta limitación puede también aplicarse a la modificación de metainformación del sistema de archivos, como los permisos o el propietario de archivo.  Recuerde cerrar (C<close>) los archivos cuando termine con ellos.  No borre (C<unlink>) o renombre (C<rename>) un archivo abierto.  No enlace (C<tie>) o abra (C<open>) un archivo que ya esté abierto o enlazado; primero haga un C<untie> o un C<close>.

No abra el mismo archivo más de una vez para escribir, ya que algunos sistemas operativos ponen bloqueos obligatorios en tales archivos.

No asuma que el modificar/escribir permisos en un directorio le da el derecho a agregar o borrar archivos/directorios en ese directorio.  Eso es específico del sistema de archivos: en algunos sistemas de archivos necesita escribir/modificar los permisos también (o incluso solo) en el propio archivo/directorio.  En algunos sistemas de archivos (AFS, DFS) el permiso para añadir/borrar entradas de directorio es un permiso completamente aparte.

No asuma que un único C<unlink> elimina completamente el archivo: algunos sistemas de archivos (más notablemente los VMS) tienen sistemas de archivos con versiones, y C<unlink()> sólo elimina la más reciente (no elimina todas las versiones porque, por defecto, las herramientas nativas de estas plataformas sólo eliminan la versión más reciente).  El modismo portable para eliminar todas las versiones de un archivo es

    1 while unlink "file";

Esto terminará si el archivo es imborrable por alguna razón (protegido, no existe, y así).

No cuente con que exista una variable de entorno C<%ENV>.
No cuente con que las entradas C<%ENV> sean sensibles al tamaño de caja, o incluso preservarlo.  No intente limpiar C<%ENV> diciendo C<%ENV = ();>, o si realmente tiene que hacerlo, hágalo con un condicional sobre C<$^O ne 'VMS'> ya que en VMS C<%ENV> es mucho más que una tabla clave por valor por proceso.

En VMS, algunas entradas en el hash C<%ENV> se crean dinámicamente cuando su clave se usa en una lectura si no existía antes.  Se sabe que los valores de C<$ENV{HOME}>, C<$ENV{TERM}>, C<$ENV{PATH}> y C<$ENV{USER}> se generan dinámicamente.  Los nombres específicos que se generan dinámicamente pueden variar con la versión de la biblioteca C en VMS, y pueden existir más que las documentadas.

En VMS, por omisión, los cambios al hash %ENV persisten después de que perl termine.
Subsecuentes invocaciones de perl en el mismo proceso pueden, inadvertidamente heredar las configuraciones de entorno que queríamos que fueran temporales.

No cuente para nada con las señales o C<%SIG>.

No cuente con la expansión de comodines en los nombres de archivo.  Use en su lugar C<opendir>, C<readdir> y C<closedir>.

No cuente con variables de entorno por proceso, o en el directorio actual por programa.

No cuente con los valores específicos de C<$!>, ni numéricos ni especialmente con las cadenas de caracteres. Los usuarios pueden cambiar sus configuraciones regionales para que los mensajes de error sean traducidos en su propio idioma.  Si puede confiar en un entorno tipo POSIX, puede usar de forma portable los símbolos definidos por el módulo C<Errno>, como C<ENOENT>.  Y no confíe en los valores de C<$!> excepto inmediatamente después de una llamada fallida al sistema.

=head2 Nombres de comandos contra nombres de rutas de archivo

No asuma que el nombre utilizado para invocar un comando o programa con C<system> o C<exec> también se puede usar para comprobar la existencia del archivo que almacena el código ejecutable para ese comando o programa.
Primero, muchos sistemas tienen comandos "internos" que están incorporados en la shell o SO, y mientras estos comandos se pueden invocar, no existe un archivo correspondiente.  Segundo, algunos sistemas operativos (p.e. Cygwin, DJGPP, OS/2 y VOS) tienen los sufijos requeridos para los archivos ejecutables; estos sufijos son, generalmente, permitidos en el nombre del comando, pero no son requeridos.  Así, un comando como F<"perl"> podría existir en un archivo con un nombre F<"perl">, F<"perl.exe">, o F<"perl.pm">, dependiendo del sistema operativo.
La variable C<"_exe"> en el módulo C<Config> alberga el sufijo ejecutable, si lo hay.  Tercero, la adaptación de VMS establece cuidadosamente C<$^X> y C<$Config{perlpath}> de modo que ya no requiera un procesamiento posterior.  Esto está bien, porque la expresión regular coincidente utilizada más abajo podría entonces tener que tratar con un posible consiguiente número de versión en el nombre del archivo VMS.

Para convertir C<$^X> a un nombre de ruta de archivo, teniendo en cuenta los requisitos de las diversas posibilidades de los sistemas operativos, escriba:

 use Config;
 my $esteperl = $^X;
 if ($^O ne 'VMS')
    {$esteperl .= $Config{_exe} unless $esteperl =~ m/$Config{_exe}$/i;}

Para convertir C<$Config{perlpath}> a un nombre de ruta de archivo, escriba:

 use Config;
 my $esteperl = $Config{perlpath};
 if ($^O ne 'VMS')
    {$esteperl .= $Config{_exe} unless $esteperl =~ m/$Config{_exe}$/i;}

=head2 Conexión a redes

No asuma que pueda acceder a Internet.

No asuma que hay una única manera de pasar a través de los cortafuegos para llegar a Internet.

No asuma que puede lograr alcanzar el mundo exterior sólo a través del puerto 80, o con algún proxy web.  Muchos cortafuegos bloquean el ftp.

No asuma que puede enviar correo electrónico conectando al puerto SMTP local.

No asuma que puede alcanzar por sí mismo cualquier nodo con el nombre 'localhost'.  Lo mismo para '127.0.0.1'.  Tendrá que probar con ambos.

No asuma que el servidor sólo tiene una tarjeta de red, o que no puede enlazarse a muchas direcciones IP virtuales.

No asuma el nombre de un particular dispositivo de red.

No asuma que un conjunto particular de C<ioctl()> vayan a funcionar.

No asuma que puede hacer ping a servidores y obtener respuestas.

No asuma que cualquier puerto (servicio) particular vaya a responder.

No asuma que C<Sys::Hostname> (o cualquier otra API o comando) devuelve, o bien un nombre de servidor totalmente cualificado, o un nombre de servidor no cualificado: todo depende de cómo el sistema se configuró.  Recuerde también que para cosas como DHCP y NAT, podría no ser útil el nombre del servidor que obtiene.

Todo lo anterior puede parecer intimidante, y lo es, pero la clave es degradar grácilmente si no puede llegar al servicio de red que quiere en particular.  Croar o colgarse no parece muy profesional.

=head2 Comunicación entre procesos (IPC)

En general, el no acceder directamente al sistema con el código significa que es portable.  Eso significa, no C<system>, C<exec>, C<fork>, C<pipe>, C<``>, C<qx//>, C<open> con un C<|>, ni cualquier otra cosa que sea de valor para un I<hacker> Perl.

Comandos que lanzan procesos externos se soportan, generalmente en la mayor parte de las plataformas (aunque muchas de ellas no soportan ningún tipo de bifurcación -fork-).  El problema al usarlos surge desde el lugar donde se invocan.  Las herramientas externas a menudo se nombran de forma diferente en diferentes plataformas, quizás no estén disponibles en la misma posición, podrían aceptar argumentos diferentes, pueden comportarse de forma diferente, y a menudo presentar sus resultados de una forma dependiente de la plataforma.  Así, debería depender raramente de ellos para producir resultados consistentes. (Entonces, otra vez, si está llamando a I<netstat -a>, probablemente no espere ejecutarlo tanto en Unix como en CP/M).

Un especialmente trozo de código común de código Perl es abrir una tubería a B<sendmail>:

    open(MAIL, '|/usr/lib/sendmail -t')
	or die "no puedo entubar con sendmail: $!";

Esto es también para sistemas de programación cuando sendmail se sabe que está disponible.  Pero no está tan bien para muchos sistemas no Unix, e incluso algunos sistemas Unix que pueden no tener sendmail instalado.  Si se necesita una solución portable, vea la diversas distribuciones en CPAN que tratan con él.  C<Mail::Mailer> y C<Mail::Send> en la distribución C<MailTools> se usan comúnmente, y proporciona diversos métodos de correo, incluyendo C<mail>, C<sendmail>, y SMTP directo (vía C<Net::SMTP>) si un agente de transferencia de correo si no está disponible.  C<Mail::Sendmail> es un módulo independiente que proporciona un sistema de correo simple e independiente de la plataforma.

El Unix System V IPC (C<msg*(), sem*(), shm*()>) no siquiera está disponible en todas las plataformas Unix.

No use el resultado simple de empaquetar con C<pack("N", 10, 20, 30, 40)> o v-cadenas (como C<v10.20.30.40>) para representar direcciones IPv4: ambas formas simplemente empaquetan los cuatro bytes en orden red.  No está garantizado que esto sea igual a un C<in_addr> struct en lenguaje C struct (que es lo que el código I<socket> usa internamente).  Para ser portable use las rutinas de la extensión C<Socket>, tales como C<inet_aton()>, C<inet_ntoa()> y C<sockaddr_in()>.

La regla de la mano derecha del código portable: Hágalo todo en Perl portable, o use un módulo (que puede implementarlo internamente con código específico de la plataforma, pero exponiendo un interfaz común).

=head2 Subrutinas externas (XS)

El código XS puede, normalmente, hacer que trabaje en cualquier plataforma, pero las bibliotecas dependientes, archivos de cabecera, etc., podrían no estar disponibles o portables, o el propio código XS podría ser específico de la plataforma, igual que el código Perl.  Si las bibliotecas y cabeceras son portables, entonces es razonable asegurarse también que el código XS también lo sea.

Un tipo diferente de problemas de portabilidad surge cuando escribe código XS: la disponibilidad de un compilador de C en el sistema del usuario final.  C trae sus propios problemas de portabilidad, y escribir código XS le expondrá a algunos de ellos.  Escribir en puro Perl es la manera más fácil de conseguir la portabilidad.

=head2 Módulos estándares

En general, los módulos estándares funcionan en todas las plataformas.  Notables excepciones son el módulo C<CPAN> (que actualmente hace conexiones a programas externos que pueden estar no disponibles), módulos específicos de plataforma (como C<ExtUtils::MM_VMS>) y módulos DBM.

No existe un módulo DBM disponible en todas las plataformas.
C<SDBM_File> y otros están disponibles generalmente en todas las adaptaciones Unix y DOS, pero no en MacPerl, donde solamente están disponibles C<NDBM_File> y C<DB_File>.

Las buenas noticias es que al menos algunos módulos DBM deberían estar disponibles, C<AnyDBM_File> usará cualquier módulo que pueda encontrar.  Naturalmente, entonces el código necesita ser bastante estricto, rebajándose al mayor factor común (p.e., no excederse de 1 K por cada registro), de modo que funcionará con cualquier módulo DBM.  Vea L<AnyDBM_File> para más detalles.

=head2 Fecha y hora

El sistema de noción de la hora del día y la fecha del calendario se controla de muchas maneras.  No asuma que la zona horaria se almacena en C<$ENV{TZ}>, e incluso si es así, no asuma que puede controlar la zona horaria por medio de esa variable.  No asuma nada sobre las abreviaturas de tres letras de las zonas horarias (por ejemplo, MST podría ser Mountain Standard Time, pero se sabe que significa Moscow Standard Time).  Si necesita usar zonas horarias, expréselas en algún formato no ambiguo como el número exacto de minutos con respecto a UTC, o el formato de zona horaria de POSIX.

No asuma que el I<epoch> empieza a las 00:00:00, del 1 de enero de 1970, porque esto es específico de la implementación y del SO.  Es mejor almacenar una fecha en una representación no ambigua.  El estándar ISO 8601 define YYYY-MM-DD como el formato de fecha, o YYYY-MM-DDTHH:MM:SS (es una "T" literal separando la fecha de la hora).
Por favor, use ISO 8601 en lugar de hacernos adivinar qué fecha podría ser 02/03/04.  ISO 8601 incluso la ordenación funciona tal cual.
Una representación en texto (como "1987-12-18") se puede convertir fácilmente en un valor específico del SO usando un módulo como C<Date::Parse>.
Un array de valores, como los que devuelve C<localtime>, se pueden convertir a una representación específica del SO usando C<Time::Local>.

Cuando calcule tiempos específicos, tales como las pruebas en módulos de fecha y hora, puede ser apropiado calcular un desplazamiento para el I<epoch>.

    require Time::Local;
    my $offset = Time::Local::timegm(0, 0, 0, 1, 0, 70);

El valor para C<$offset> en Unix será C<0>, pero en Mac OS Classic será un número grande.  Entonces C<$offset> se puede añadir a un valor de hora Unix para obtener lo que tendría que ser el valor apropiado en cualquier sistema.

=head2 Codificación de caracteres y juegos de caracteres

Asuma muy poco de todo lo relacionado sobre los conjuntos de caracteres.

No asuma nada sobre los valores numéricos (C<ord>, C<chr>) de los caracteres.
No use rangos de puntos de código explícitos (como C<\xHH-\xHH)>.  Aun así, a partir de Perl v5.22, rangos en clases de caracteres entre corchetes en patrones de expresiones regulares especificados como C<qr/[\N{U+HH}-\N{U+HH}]/> son portables, y a partir de Perl v5.24, los mismos rangos son portables en C<tr///>.
Puede usar de forma portable clases de caracteres simbólicos como C<[:print:]>.

No asuma que los caracteres alfabéticos están codificados de manera contigua (en el sentido numérico).  Puede haber intervalos vacíos.  Una codificación especial en Perl, sin embargo, garantiza que todos los subconjuntos de C<qr/[A-Z]/>, C<qr/[a-z]/> y C<qr/[0-9]/> se comportan como se espera.  C<tr///> se comporta de la misma manera para estos rangos.  En patrones, cualquier rango especificado con puntos finales usando la notación C<\N{...}> asegura la portabilidad del conjunto de caracteres, pero es un error en Perl v5.22, pero no para C<tr///>, arreglado en v5.24.

No asuma nada sobre la ordenación de los caracteres.
Las letras minúsculas pueden venir antes o después de las letras mayúsculas; las minúsculas y mayúsculas pueden estar intercaladas, por lo que las dos letras "a" y "A" vienen antes que "b"; los caracteres acentuados e internacionales pueden estar intercalados, por lo que "E<auml>" viene antes que "b".
L<Unicode::Collate> se pueden usar para sortear todo esto.

=head2 Internacionalización

Si puede asumir POSIX (una suposición bastante grande), puede leer más sobre el sistema de configuración regional POSIX en L<perllocale>.  El sistema de configuración regional intenta al menos hacer las cosas un poco más portables, o al menos más convenientes y amigables para los usuarios no anglosajones.  El sistema afecta a los conjuntos de caracteres y codificación, y formateo de la fecha y hora, entre otras cosas.

Si realmente quiere ser internacional, debería considerar Unicode.
Vea L<perluniintro> y L<perlunicode> para más información.

Si quiere usar bytes no ASCII (fuera de los bytes 0x00..0x7f) en el "código fuente" de su código, para ser portable tiene que ser explícito sobre qué bytes son.  Alguien podría, por ejemplo, usar su código bajo una configuración regional UTF-8, en cuyo caso bytes nativos aleatorios podrían ser ilegales ("Malformed UTF-8 ..."). Esto significa que, por ejemplo, integrar bytes ISO 8859-1 más allá de 0x7f en sus cadenas podrían causar problemas más tarde.  Si los bytes son bytes nativos de 8 bits, puede usar el I<pragma> C<bytes>.  Si los bytes están en una cadena (las expresiones regulares son cadenas peculiares), puede a menudo también usar C<\xHH>, o con más portabilidad, la notación C<\N{U+HH}> en lugar de integrar los bytes directamente.  Si quiere escribir su código en UTF-8, puede usar L<utf8>.

=head2 Recurso del sistema

Si su código se destina a sistemas con memoria virtual severamente restrictiva (¡o inexistente!) entonces querrá estar I<especialmente> atento para evitar construcciones despilfarradoras como estas:

    my @lineas = <$archivo_muy_grande>;        # malo

    while (<$fh>) {$archivo .= $_}             # a veces malo
    my $archivo = join('', <$fh>);             # mejor

Las dos últimas construcciones pueden parecer contra intuitivas para la mayor parte de la gente.  La primera crece una cadena repetidamente, mientras que la segunda asigna un gran bloque de memoria en una sola sentencia.  En algunos sistemas, la segunda es más eficiente que la primera.

=head2 Seguridad

La mayor parte de las plataformas multiusuario proporcionan niveles básicos de seguridad, normalmente implementado a nivel del sistema de archivos.  Algunos no, desgraciadamente.  Por ello, la idea de id de usuario, o directorio "home", o incluso el estado de estar registrado, pueden ser irreconocibles en muchas plataformas.  Si escribe programas que sean conscientes de la seguridad, normalmente lo mejor es saber en qué tipo de sistema se ejecutarán para que pueda escribir código explícito para esa plataforma (o clase de plataformas).

No asuma la semántica de acceso al sistema de archivos de Unix: el sistema operativo o el sistema de archivos pueden usar algunos sistemas ACL, que son lenguajes mucho más ricos que el habitual C<rwx>.  Incluso si existe C<rwx>, su semántica podría ser diferente.

(Desde el punto de vista de la seguridad, comprobar los permisos antes de intentar hacer algo es en todo caso tonto: si lo intenta, hay una potencial condición de carrera. Alguien o algo podrían cambiar los permisos entre las comprobaciones de permisos y la operación real.
Simplemente, pruebe a realizar la operación).

No asuma la semántica de usuario y grupo de Unix: especialmente, no espere que C<< $< >> y C<< $> >> (o C<$(> y C<$)>) funcionen para cambiar identidades (o afiliaciones).

No asuma la semántica de set-uid y set-gid. (E incluso si lo hace, piénselo dos veces: set-uid y set-gid se conocen como una lata de gusanos -agujeros- de seguridad).

=head2 Estilo

Para esos momentos cuando es necesario tener código específico de la plataforma, considere mantener el código específico de la plataforma en un único sitio, haciendo más sencilla la portabilidad a otras plataformas.  Use el módulo C<Config> y la variable especial C<$^O> para diferenciar plataformas, como se describe en L<"PLATAFORMAS">.

Cuidado con el "síndrome del else":

  if ($^O eq 'MSWin32') {
    # código que asume Windows
  } else {
    # código que asume Linux
  }

La rama C<else> debería usarse para la realmente última y definitiva opción, no para código específico de alguna plataforma.

Sea cuidadoso en las pruebas para suministrar sus módulos o programas.
El código del módulo puede ser plenamente portable, pero sus pruebas podrían no serlo.  Esto sucede a menudo cuando las pruebas lanzan otros procesos o llaman a programas externos para ayudarle en la comprobación, o cuando (como se ha anotado antes) las pruebas asumen ciertas cosas del sistema de archivos y rutas.  Sea cuidadoso de no depender de un estilo específico de salida para los errores, tales como cuando comprueba C<$!> después de una fallida llamada al sistema.  Usar C<$!> para ninguna otra cosa que mostrarlo como salida, es algo escaso (aún así vea el módulo C<Errno> para comprobar, razonablemente y de forma portable por los valores de error). Algunas plataformas esperan un cierto formato de salida, y Perl en estas plataformas puede ajustarse consiguientemente.  Más específicamente, no se ancle a una I<regex> cuando compruebe un valor de error.

=head1 Testeadores CPAN

Los módulos subidos a CPAN se prueban por una variedad de voluntarios en diferentes plataformas.  A estos probadores de CPAN se les notifica por correo de cada nueva subida, y responde a la lista con PASS (pasa), FAIL (falla), NA (no aplicable a esta plataforma), o UNKNOWN (desconocido), junto con anotaciones relevantes.

El propósito de las pruebas es doble: una, para ayudar a los desarrolladores arreglar cualquier problema en su código que aparezca debido a la falta de pruebas en otras plataformas; dos, proporcionar a los usuarios con información sobre si un módulo dado funciona en una plataforma dada.

Vea también:

=over 4

=item *

Lista de correo: cpan-testers-discuss@perl.org

=item *

Resultados de las pruebas: L<http://www.cpantesters.org/>

=back

=head1 PLATAFORMAS

Perl se compila con una variable, C<$^O>, que indica el sistema operativo en que se compiló.  Esto se implementó para ayudar a aumentar la velocidad del código, que de otra manera tendría que usar C<use Config> y usar el valor de C<$Config{osname}>.  Naturalmente, para obtener más información detallada sobre el sistema, mirar en C<%Config> es ciertamente lo recomendado.

Aun así, C<%Config> no siempre es confiable, porque se define en tiempo de compilación.  Si perl se compila en un lugar, y luego se lleva a otro, algunos valores pueden ser erróneos.  Los valores pueden incluso haberse editado después de la compilación.

=head2 Unix

Perl funciona en una desconcertante variedad de Unix y plataformas parecidos a Unix (vea p.e. la mayor parte de los archivos en el directorio F<hints/> en la distribución del código fuente).
En la mayor parte de estos sistemas, el valor de C<$^O> (y por ello también C<$Config{'osname'}>) se determina, o bien pasando a minúsculas y quitando los signos de puntuación del primer campo devuelto por C<uname -a> (o comando similar) en el símbolo del sistema, o mirando por el sistema de archivos por la presencia de archivos únicos tales como el kernel o el archivo de cabecera.  Aquí, por ejemplo, hay unos pocos de los más populares sabores de Unix:

    uname         $^O        $Config{'archname'}
    --------------------------------------------
    AIX           aix        aix
    BSD/OS        bsdos      i386-bsdos
    Darwin        darwin     darwin
    DYNIX/ptx     dynixptx   i386-dynixptx
    FreeBSD       freebsd    freebsd-i386
    Haiku         haiku      BePC-haiku
    Linux         linux      arm-linux
    Linux         linux      armv5tel-linux
    Linux         linux      i386-linux
    Linux         linux      i586-linux
    Linux         linux      ppc-linux
    HP-UX         hpux       PA-RISC1.1
    IRIX          irix       irix
    Mac OS X      darwin     darwin
    NeXT 3        next       next-fat
    NeXT 4        next       OPENSTEP-Mach
    openbsd       openbsd    i386-openbsd
    OSF1          dec_osf    alpha-dec_osf
    reliantunix-n svr4       RM400-svr4
    SCO_SV        sco_sv     i386-sco_sv
    SINIX-N       svr4       RM400-svr4
    sn4609        unicos     CRAY_C90-unicos
    sn6521        unicosmk   t3e-unicosmk
    sn9617        unicos     CRAY_J90-unicos
    SunOS         solaris    sun4-solaris
    SunOS         solaris    i86pc-solaris
    SunOS4        sunos      sun4-sunos

Debido a que el valor de C<$Config{archname}> puede depender de la arquitectura hardware, puede ser más variado que el valor de C<$^O>.

=head2 DOS y derivados

Perl hace mucho tiempo que se portó a microcomputadoras de estilo Intel corriendo bajo sistemas como PC-DOS, MS-DOS, OS/2, y más plataformas Windows de las que puedas mencionar (excepto para Windows CE, si cuenta con él).
Los usuarios familiarizados con los shell estilo I<COMMAND.COM> o I<CMD.EXE> deberían ser conscientes de que cada una de estas especificaciones de archivo pueden tener diferencias sutiles:

    my $filespec0 = "c:/foo/bar/file.txt";
    my $filespec1 = "c:\\foo\\bar\\file.txt";
    my $filespec2 = 'c:\foo\bar\file.txt';
    my $filespec3 = 'c:\\foo\\bar\\file.txt';

Las llamadas al sistema aceptan tanto C</> o C<\> como separadores de ruta.
Aun así, muchas utilidades en línea de comandos tratan al I<vintage> C</> del DOS como prefijo de opciones, así que pueden quedarse confusas con nombres de archivo que contengan C</>.
Aparte de llamar a cualquier programa externo, C</> funcionará bien, y probablemente mejor, ya que es más consistente con el uso popular, y evita el problema de recordar qué mantener y qué no.

El sistema de archivos FAT del DOS solo pueden acomodar nombres de archivo del estilo "8.3".  Estando en uso el "insensible al tamaño de caja, pero preservándolo", en los sistemas de archivos HPFS (OS/2) y NTFS (NT), deberá tener cuidado sobre el tamaño de caja devuelto por las funciones, como C<readdir>, o usado en funciones como C<open> u C<opendir>.

DOS también trata a muchos nombres de archivo como especiales, tales como AUX, PRN, NUL, CON, COM1, LPT1, LPT2, etc. Desafortunadamente, algunas veces estos nombres de archivo ni siquiera funcionarán si incluye un explícito prefijo de directorio.  Es mejor evitar tales nombres de archivo si quiere que su código sea portable a DOS y derivados.  Desgraciadamente, es difícil saber cuáles son.

Los usuarios de estos sistemas operativos pueden también desear hacer uso de I<scripts> tales como I<pl2bat.bat> o I<pl2cmd> para poner envoltorios alrededor de sus I<scripts>.

La nueva línea (C<\n>) se traduce a C<\015\012> en STDIO cuando se lee o se escribe a archivos (vea L<"Newlines">).  C<binmode(IDENTIFICADOR DE ARCHIVO)> mantendrá C<\n> traducido como C<\012> para ese identificador de archivo.  Ya que es una no-operación en otros sistemas, C<binmode> debería usarse por código cruzado que gestione datos en binario.  Asume que sabe por adelantado que sus datos están en binario.  Los programas de propósito general no deberían asumir nada sobre sus datos.

Los valores de la variable C<$^O> y de C<$Config{archname}>, para varios perl en DOS, son como sigue:

     OS            $^O      $Config{archname}   ID    Versión
     --------------------------------------------------------
     MS-DOS        dos        ?
     PC-DOS        dos        ?
     OS/2          os2        ?
     Windows 3.1   ?          ?                 0      3 01
     Windows 95    MSWin32    MSWin32-x86       1      4 00
     Windows 98    MSWin32    MSWin32-x86       1      4 10
     Windows ME    MSWin32    MSWin32-x86       1      ?
     Windows NT    MSWin32    MSWin32-x86       2      4 xx
     Windows NT    MSWin32    MSWin32-ALPHA     2      4 xx
     Windows NT    MSWin32    MSWin32-ppc       2      4 xx
     Windows 2000  MSWin32    MSWin32-x86       2      5 00
     Windows XP    MSWin32    MSWin32-x86       2      5 01
     Windows 2003  MSWin32    MSWin32-x86       2      5 02
     Windows Vista MSWin32    MSWin32-x86       2      6 00
     Windows 7     MSWin32    MSWin32-x86       2      6 01
     Windows 7     MSWin32    MSWin32-x64       2      6 01
     Windows 2008  MSWin32    MSWin32-x86       2      6 01
     Windows 2008  MSWin32    MSWin32-x64       2      6 01
     Windows CE    MSWin32    ?                 3
     Cygwin        cygwin     cygwin

Los diversos Perl de MSWin32 pueden distinguir el SO en que se ejecutan por medio del valor del quinto elemento de la lista devuelta por C<Win32::GetOSVersion()>.  Por ejemplo:

    if ($^O eq 'MSWin32') {
        my @os_version_info = Win32::GetOSVersion();
        print +('3.1','95','NT')[$os_version_info[4]],"\n";
    }

Existen también C<Win32::IsWinNT()> y C<Win32::IsWin95()>; pruebe C<perldoc Win32>, y por medio de libwin32 0.19 (no parte del núcleo principal de la distribución Perl), C<Win32::GetOSName()>.  También funcionará el muy portable C<POSIX::uname()>:

    c:\> perl -MPOSIX -we "print join '|', uname"
    Windows NT|moonru|5.0|Build 2195 (Service Pack 2)|x86

Vea también:

=over 4

=item *

El entorno djgpp para DOS, L<http://www.delorie.com/djgpp/> y L<perldos>.

=item *

El entorno EMX para DOS, OS/2, etc. emx@iaehv.nl, L<ftp://hobbes.nmsu.edu/pub/os2/dev/emx/> También L<perlos2>.

=item *

Instrucciones de compilación para Win32 en L<perlwin32>, o bajo el entorno Cygnus en L<perlcygwin>.

=item *

Los módulos C<Win32::*> en L<Win32>.

=item *

Las páginas en ActiveState, L<http://www.activestate.com/>

=item *

El entorno Cygwin para Win32; F<README.cygwin> (instalado como L<perlcygwin>), L<http://www.cygwin.com/>

=item *

El entorno U/WIN para Win32, L<http://www.research.att.com/sw/tools/uwin/>

=item *

Las instrucciones de compilación de OS/2, L<perlos2>

=back

=head2 VMS

Perl en VMS se discute en L<perlvms> en la distribución Perl.

El nombre oficial de VMS en el momento de escribir esto es OpenVMS.

Interactuar con Perl desde el shell I<Digital Command Language> (DCL) requiere a menudo un entrecomillado diferente que en los shell Unix.
Por ejemplo:

    $ perl -e "print ""Hola, mundo.\n"""
    Hola, mundo.

Hay varias maneras de envolver sus I<scripts> Perl en los archivos DCL F<.COM>, si está inclinado a ello.  Por ejemplo:

    $ write sys$output "¡Hola desde DCL!"
    $ if p1 .eqs. ""
    $ then perl -x 'f$environment("PROCEDURE")
    $ else perl -x - 'p1 'p2 'p3 'p4 'p5 'p6 'p7 'p8
    $ deck/dollars="__END__"
    #!/usr/bin/perl

    print "¡Hola desde Perl!\n";

    __END__
    $ endif

Tenga cuidado con C<$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT> si su I<script> Perl-en-DCL espera hacer cosas como C<< $read = <STDIN>; >>.

El sistema operativo VMS tiene dos sistemas de archivos, designados por su nivel estructura en disco (I<on-disk structure> (ODS)): ODS-2 y su sucesor ODS-5.  La adaptación inicial de Perl a VMS depreda ODS-5, pero todas las pruebas actuales y el desarrollo asume ODS-5 y sus capacidades, incluyendo la preservación del tamaño de caja, caracteres extendidos en la especificación de archivos, y nombres de hasta 8192 bytes de largo.

Perl en VMS puede aceptar, tanto estilos de especificaciones de archivo VMS o Unix, como uno de los siguientes:

    $ perl -ne "print if /perl_setup/i" SYS$LOGIN:LOGIN.COM
    $ perl -ne "print if /perl_setup/i" /sys$login/login.com

pero no una mezcla de ambos, como en:

    $ perl -ne "print if /perl_setup/i" sys$login:/login.com
    Can't open sys$login:/login.com: file specification syntax error

En general, el camino más fácil para la portabilidad es siempre especificar nombres de archivo en formato Unix a menos que necesiten procesarse por comandos nativos o utilidades.  Debido a esta última consideración, el módulo File::Spec devuelve, por defecto, especificaciones de formato nativo, independiente del formato de entrada.  Estos valores por defecto pueden revertirse, y así los nombres de archivo se reportan siempre en formato Unix especificando la característica lógica C<DECC$FILENAME_UNIX_REPORT> en el entorno.

El tipo de archivo, o extensión, siempre está presente en la especificación de formato de archivo VMS incluso si es de longitud cero.  Esto significa que, por defecto, C<readdir> devolverá un punto final en un archivo que no tenga extensión, así que podrá ver que un C<"a"> en Unix será C<"a."> en VMS.  Aun así, el punto final puede ser suprimido activando la característica C<DECC$READDIR_DROPDOTNOTYPE> en el entorno (vea la documentación de CRTL sobre los nombres de las característica lógicas).

Lo que C<\n> representa depende del tipo de archivo abierto.  Normalmente representa C<\012> pero podría ser también C<\015>, C<\012>, C<\015\012>, C<\000>, C<\040> o nada, dependiendo de la organización de archivos y el formato de registro.  El módulo C<VMS::Stdio> proporciona acceso a los requisitos especiales de C<fopen()> sobre archivos con atributos inusuales en VMS.

El valor de C<$^O> en OpenVMS es "VMS".  Para determinar la arquitectura en la que está ejecutándose, refiérase a C<$Config{'archname'}>.

En VMS, perl determina el desplazamiento UTC a partir del nombre lógico C<SYS$TIMEZONE_DIFFERENTIAL>.  A pesar de que el I<epoch> de VMS comienza el 17-NOV-1858 00:00:00.00, las llamadas a C<localtime> se ajustan para contar los desplazamientos a partir de 01-JAN-1970 00:00:00.00, igual que Unix.

Vea también:

=over 4

=item *

F<README.vms> (instalado como F<README_vms>), L<perlvms>

=item *

vmsperl list, vmsperl-subscribe@perl.org

=item *

vmsperl en la web, L<http://www.sidhe.org/vmsperl/index.html>

=item *

VMS Software Inc. sitio web, L<http://www.vmssoftware.com>

=back

=head2 VOS

Perl en VOS (también conocido como OpenVOS) se explica en F<README.vos> en la distribución Perl (instalado como L<perlvos>).  Perl en VOS puede aceptar, tanto estilos de especificaciones de archivo VOS o Unix, como uno de los siguientes:

    $ perl -ne "print if /perl_setup/i" >system>notices
    $ perl -ne "print if /perl_setup/i" /system/notices

o incluso una mezcla de ambos, como en:

    $ perl -ne "print if /perl_setup/i" >system/notices

Incluso aunque VOS permita que el carácter barra inclinada aparezca en los objetos nombre, debido a que la adaptación VOS de Perl lo interpreta como un carácter delimitador del nombre de la ruta, archivos VOS, directorios, o enlaces cuyos nombres contienen un carácter barra, no pueden procesarse.  Tales archivos deben renombrarse antes de poder procesarse por Perl.

Distribuciones anteriores de VOS (anteriores a OpenVOS Release 17.0) limitan los nombres de archivo a 32 o menos caracteres, prohíben nombres de archivo que empiecen con un carácter C<->, y prohíben nombres de archivo que contengan cualquier carácter que coincida con C<< tr/ !#%&'()*;<=>?// >>.

Nuevas distribuciones de VOS (OpenVOS Release 17.0 o siguientes) soporta una característica conocida como nombres extendidos.  En estas distribuciones, los nombres de archivo pueden contener hasta 255 caracteres, tienen prohibido comenzar con un carácter C<->, y el conjunto de caracteres prohibidos se reduce a cualquier carácter que coincida con C<< tr/#%*<>?// >>.  Hay restricciones que incluyen a los espacios y apóstrofes: estos caracteres no deben comenzar o terminar un nombre, ni pueden preceder o seguir inmediatamente a un punto.  Además, un espacio no debe preceder inmediatamente a otro espacio o guión.  Específicamente, las siguientes combinaciones de caracteres están prohibidas: espacio-espacio, espacio-guión, punto-espacio, espacio-punto, punto-apóstrofe, apóstrofe-punto, espacios por delante o detrás, y apóstrofe por delante o detrás.  A pesar de que un nombre de archivo extendido está limitado a 255 caracteres, un nombre de ruta sigue estando limitado a 256 caracteres.

El valor de C<$^O> en VOS es "vos".  Para determinar la arquitectura en la que se está ejecutando sin recurrir a cargar todo C<%Config> puede examinar el contenido del array C<@INC>, así:

    if ($^O =~ /vos/) {
        print "¡Estoy en una caja Stratus!\n";
    } else {
        print "¡No estoy en una caja Stratus!\n";
        die;
    }

Vea también:

=over 4

=item *

F<README.vos> (instalado como L<perlvos>)

=item *

La lista de correo VOS.

No hay una lista de correo específica para Perl en VOS.  Puede contactar con el centro de asistencia al cliente de Stratus Technologies (CAC) de su zona, o puede usar la información de contacto indicada en los archivos de la distribución en el sitio FTP anónimo de Stratus.

=item *

Stratus Technologies en la web en L<http://www.stratus.com>

=item *

VOS Open-Source Software en la web en L<http://ftp.stratus.com/pub/vos/vos.html>

=back

=head2 Plataformas EBCDIC

Perl v5.22 corre en z/OS (anteriormente OS/390).  Teóricamente podría ejecutarse en los sucesores del OS/400 en minicomputadores AS/400 así como VM/ESA, y BS2000 para servidor corporativos S/390.  Tales computadores usan internamente los conjuntos de caracteres EBCDIC (normalmente I<Character Code Set> ID 0037 para OS/400 y tanto 1047 como POSIX-BC para S/390 systems).

El resto de esta sección puede necesitar actualización, pero no sabemos qué podría ser.  Por favor, envíe sus comentarios por correo a L<perlbug@perl.org|mailto:perlbug@perl.org>

En los servidores corporativos, Perl funciona actualmente bajo el "I<Unix system services for OS/390>" (anteriormente conocido por OpenEdition), VM/ESA OpenEdition, o el BS200 POSIX-BC system (BS2000 está soportado en Perl v5.6 y siguientes).
Vea L<perlos390> para más detalles.  Note que para OS/400 existe también una adaptación de Perl 5.8.1/5.10.0 o siguientes a el PASE que está basado en ASCII (opuesto a ILE que está basado en EBCDIC). Vea L<perlos400>.

Para R2.5 de USS para OS/390 y Version 2.3 de VM/ESA, estos subsistemas Unix no soportan el truco I<shebang> C<#!> para la invocación de I<scripts>.
Por ello, en I<scripts> Perl OS/390 y VM/ESA se pueden ejecutar con una cabecera similar al siguiente script sencillo:

    : # use perl
        eval 'exec /usr/local/bin/perl -S $0 ${1+"$@"}'
            if 0;
    #!/usr/local/bin/perl     # realmente es un comentario

    print "¡Hola desde Perl!\n";

OS/390 soportará el truco I<shebang> C<#!> en la distribución 2.8 y siguientes.
Las llamadas a C<system> y comillas inversas pueden usar la sintaxis shell POSIX en todos los sistemas S/390.

En el AS/400, si PERL5 está en su lista de bibliotecas, puede necesitar envolver sus I<scripts> Perl en un procedimiento CL para invocarlos así:

    BEGIN
      CALL PGM(PERL5/PERL) PARM('/QOpenSys/hello.pl')
    ENDPGM

Esto invocará el I<script> Perl F<hello.pl> en la raíz del sistema de archivo QOpenSys.  En las llamadas AS/400 a C<system> o comillas inversas deben usar la sintaxis CL.

En estas plataformas, tener en mente que el conjunto de caracteres EBCDIC puede tener un efecto sobre lo que sucede con algunas funciones Perl (tales como C<chr>, C<pack>, C<print>, C<printf>, C<ord>, C<sort>, C<sprintf>, C<unpack>), así como manejo de bits con constantes ASCII usando operadores como C<^>, C<&> y C<|>, sin mencionar el trato con los interfaces I<socket> a ordenadores ASCII (vea L<"Newlines">).

Afortunadamente, la mayor parte de los servidores web para servidores corporativos traducirán correctamente el C<\n> en la siguiente sentencia a su equivalente ASCII (C<\r> es la mismo bajo Unix y z/OS):

    print "Content-type: text/html\r\n\r\n";

Los valores de C<$^O> en algunas de estas plataformas incluyen:

    uname         $^O        $Config{'archname'}
    --------------------------------------------
    OS/390        os390      os390
    OS400         os400      os400
    POSIX-BC      posix-bc   BS2000-posix-bc

Algunos trucos sencillos para determinar si está ejecutándose en una plataforma EBCDIC podría ser cualquiera de los siguientes (quizás todos):

    if ("\t" eq "\005")   { print "¡Aquí se puede hablar EBCDIC!\n"; }

    if (ord('A') == 193) { print "¡Aquí se puede hablar EBCDIC!\n"; }

    if (chr(169) eq 'z') { print "¡Aquí se puede hablar EBCDIC!\n"; }

Una cosa que quizás no quiera es confiar en la codificación EBCDIC de los caracteres de puntuación ya que estos pueden diferir de una página de códigos a otra (y una vez que se sepa que su módulo o I<script> funciona con EBCDIC, otra gente querrá que funcione con todos los conjuntos de caracteres EBCDIC).

Vea también:

=over 4

=item *

L<perlos390>, L<perlos400>, L<perlbs2000>, L<perlebcdic>.

=item *

La lista perl-mvs@perl.org está para hablar de los problemas de adaptación así como de problemas de uso general para todos los Perl de EBCDIC.  Mande un mensaje con el texto "subscribe perl-mvs" a majordomo@perl.org

=item *

Información sobre Perl en AS/400 en L<http://as400.rochester.ibm.com/> así como en CPAN en el directorio F<ports/>

=back

=head2 S.O. Acorn RISC

Debido a que Acorns usa ASCII con caracteres de nuevas líneas (C<\n>) en archivos de texto como C<\012> como Unix, y por que la emulación de los nombres de archivo Unix está activada por defecto, la mayor parte de los I<scripts> sencillos probablemente funcionarán "tal cual salen de la caja".  El sistema de archivos nativo es modular, y los sistemas de archivos individuales son libres de ser sensibles o no al tamaño de caja, y normalmente suelen preservar ese tamaño de caja.  Algunos sistemas de archivos nativos tienen límites en la longitud de los nombres, por lo cual los nombres de archivos y directorios se truncarán silenciosamente para que entren.  Los I<scripts> tienen que ser conscientes de que el sistema de archivos estándar actual tiene un límite de longitud de nombre de B<10> caracteres, y con 77 en un directorio, pero otros sistemas de archivos pueden no imponer estas limitaciones.

Los nombres de archivo son de la forma

    SistemaArchivo#CampoEspecial::NombreDisco.$.Directorio.Directorio.Archivo

donde

    CampoEspecial no está presente de forma normal, pero puede contener . y $
    SistemaArchivo =~ m|[A-Za-z0-9_]|
    NombreDisco    =~ m|[A-Za-z0-9_/]|
    $ representa el directorio raíz
    . es el separador de rutas
    @ es el directorio actual (por sistema de archivos pero a nivel de máquina global)
    ^ es el directorio padre
    Directorio y Archivo =~ m|[^\0- "\.\$\%\&:\@\\^\|\177]+|

La traducción de nombres de archivo por defecto es aproximadamente C<tr|/.|./|;>

Note que C<"ADFS::DiscoDuro.$.Archivo" ne 'ADFS::DiscoDuro.$.Archivo'> y que la segunda etapa de la interpolación de C<$> en expresiones regulares se confundirá con C<$.> si los I<scripts> no tienen cuidado.

También se permiten las rutas lógicas especificadas por las variables del sistema que contengan una lista de búsquedas separadas por comas; por tanto C<System:Modules> es un nombre de archivo válido, y el sistema de archivos prefijará C<Modules> con cada sección de C<System$Path> hasta que un nombre apunte a un objeto en disco.
Se permite escribir a un nuevo archivo C<System:Modules> solo si C<System$Path> contiene un único elemento de lista.  El sistema de archivos también expandirá variables en los nombres de archivo si se encierran entre ángulos, así que C<< <System$Dir>.Modules >> buscará por el archivo S<C<$ENV{'System$Dir'} . 'Modules'>>.  La implicación obvia de esto es que B<los nombres de archivo totalmente cualificados pueden empezar con C<< <> >>> y deben protegerse cuando se use C<open> como entrada.

Debido a que C<.> estaba en uso como separador de directorio y no se puede asumir que los nombres de archivo puedan ser únicos con 10 caracteres, Acorn implementó el compilador de C para que eliminara los sufijos finales C<.c> C<.h> C<.s> y C<.o> de los nombres de archivo especificados en el código fuente y almacenar los archivos respectivos en subdirectorios con un nombre que sigue al sufijo.  Por ello los archivos se traducen:

    foo.h           h.foo
    C:foo.h         C:h.foo        (variable de ruta lógica)
    sys/os.h        sys.h.os       (el compilador de C murmura Unix)
    10charname.c    c.10charname
    10charname.o    o.10charname
    11charname_.c   c.11charname   (asumiendo que el sistema de archivos trunca a 10)

La emulación Unix de la biblioteca de traducción de nombres de archivo a nativo asume que se requiere esta suerte de traducción, y permite una lista de sufijos conocidos definida por el usuario que traducirá de este modo.  Esto puede parecer transparente, pero considere que con esas reglas, tanto F<foo/bar/baz.h> como F<foo/bar/h/baz> se mapean a F<foo.bar.h.baz>, y que C<readdir> y C<glob> no pueden ni intentar emular el mapeo inverso.  Cualquier C<.> en los nombres de archivo se traducen a C</>.

Como se indicó antes, el entorno que se accede a través de C<%ENV> es global, y la convención es que las variables de entorno específicas del programa son de la forma C<Programa$Nombre>.  Cada sistema de archivos mantiene un directorio actual, y el directorio actual del sistema de archivos actual es el directorio actual B<global>.  Por lo tanto, los programas amigables no cambian el directorio actual, sino que confían en rutas completas, y los programas (y Makefiles) no pueden asumir que pueden desdoblarse en un proceso hijo que puede cambiar el directorio actual sin afectar a su padre (y a todos los demás para este tema).

Debido a que los identificadores de archivo nativos del sistema operativo son globales y, actualmente asignados por debajo de 255, siendo el 0 un valor reservado, la biblioteca de emulación Unix emula a los identificadores de archivo Unix.  Consecuentemente, no puede confiar en pasar C<STDIN>, C<STDOUT> o C<STDERR> a sus hijos.

El deseo de los usuarios de expresar nombres de archivo de la forma C<< <Foo$Dir>.Bar >> en la línea de comandos sin comillas causa problemas, también: la captura de la salida del comando C<``> tiene que realizar un juego de adivinanzas.  Asume que una cadena C<< <[^<>]+\$[^<>]> >> es una referencia a una variable de entorno, mientras que cualquier cosa que tenga un C<< < >> o C<< > >> es una redirección, algo que generalmente gestiona de forma correcta en el 99 % de los casos.  Naturalmente, el problema queda en los I<scripts> que no pueden confiar en que estén disponibles ninguna de las herramientas Unix, o que cualquier herramienta encontrada tenga unos argumentos de línea de comandos parecidos a los de Unix.

Extensiones y XS son, en teoria, compilables por cualquiera usando herramientas libres.  En la práctica, muchas no lo son, como el caso de los usuarios de la plataforma Acorn que utilizan distribuciones binarias.  MakeMaker funciona, pero no está disponible un make que soporte los makefiles de MakeMaker; incluso si y cuando esto esté arreglado, la carencia de un shell tipo Unix causará problemas con las reglas makefile, especialmente con líneas de la forma C<cd sdbm && make all>, y cualquier otra cosa que use entrecomillado.

"S<RISC OS>" es el nombre apropiado para el sistema operativo, pero el valor en C<$^O> es "riscos" (porque no queremos gritarlo).

=head2 Otros perl

Perl se ha portado a muchas plataformas que no encajan en ninguna de las categorías listadas antes.  Algunas, tales como AmigaOS, QNX, Plan 9 y VOS, se han integrado bien en el conjunto de código fuente estándar de Perl.  Puede necesitar ver el directorio F<ports/> en CPAN para información, y posiblemente binarios, para algunos como: aos, Atari ST, lynxos, riscos, Novell Netware, Tandem Guardian, I<etc.> (Sí, sabemos que algunos de estos SO pueden caer bajo la categoría Unix, pero no somos un cuerpo de estándares).

Algunos nombres parecidos de sistemas operativos y sus valores en la categoría "OTHER" incluye:

    OS            $^O        $Config{'archname'}
    ------------------------------------------
    Amiga DOS     amigaos    m68k-amigos

Vea también:

=over 4

=item *

Amiga, F<README.amiga> (instalado como L<perlamiga>).

=item *

Un PERL.NLM basado en una versión libre de perl5 para Novell Netware está disponible en binario precompilado y en forma de código fuente en L<http://www.novell.com/> así como en CPAN.

=item  *

S<Plan 9>, F<README.plan9>

=back

=head1 IMPLEMENTACIONES DE FUNCIONES

Abajo se lista las funciones que no están completamente implementadas o se han implementado de forma diferente en diversas plataformas.
Siguiendo a cada descripción, en paréntesis, una lista de plataformas a los que aplica la descripción.

La lista puede estar incompleta, o incluso equivocada en algunos lugares.  En caso de duda, consulte los archivos README específicos de la plataforma en la distribución de código fuente de Perl, y cualesquiera otros recursos de documentación que acompañen a la adaptación indicada.

Sea consciente, además, que incluso en los sistemas tipo Unix existen variaciones.

Para muchas funciones, también puede consultar C<%Config>, exportada por defecto desde el módulo C<Config>.  Por ejemplo, para comprobar si una plataforma tiene la llamada C<lstat>, compruebe C<$Config{d_lstat}>.  Vea L<Config> para una descripción completa de variables disponibles.

=head2 Lista de funciones de Perl en orden alfabético

=over 8

=item -X

C<-w> sólo inspecciona el atributo de solo lectura de archivo (FILE_ATTRIBUTE_READONLY), que determina si el directorio se puede borrar, no si se puede escribir en él. Los directorios siempre tienen acceso de lectura y escritura a menos que se le deniegue por las listas de control de acceso discrecionales (DACL).  (S<Win32>)

C<-r>, C<-w>, C<-x> y C<-o> indican cuándo el archivo es accesible, que quizás no reflejen las protecciones de archivo basadas en UIC.  (VMS)

C<-s> con el nombre de un archivo abierto devolverá el espacio reservado en disco, en lugar del tamaño actual.  C<-s> en un identificador de archivo devuelve el tamaño actual.  (S<RISC OS>)

C<-R>, C<-W>, C<-X>, C<-O> son indistinguibles de C<-r>, C<-w>, C<-x>, C<-o>. (Win32, VMS, S<RISC OS>)

C<-g>, C<-k>, C<-l>, C<-u>, C<-A> no son particularmente significativos.
(Win32, VMS, S<RISC OS>)

C<-p> no es particularmente significativo. (VMS, S<RISC OS>)

C<-d> es verdadero si se le pasa una especificación de dispositivo sin un directorio explícito.
(VMS)

C<-x> (o C<-X>) determina si un archivo termina en uno de los sufijos ejecutables.  C<-S> no tiene sentido.  (Win32)

C<-x> (o C<-X>) determina si un archivo es de un tipo de archivo ejecutable.
(S<RISC OS>)

=item alarm

Emulado usando temporizadores que deben ser explícitamente consultados si Perl quiere despachar "señales seguras" y por tanto no puede interrumpir llamadas del sistema bloqueantes.  (Win32)

=item atan2

Debido a problemas con diversas CPU, bibliotecas matemáticas, compiladores y estándares, los resultados de C<atan2()> pueden variar dependiendo de alguna combinación de lo anterior.
Perl intenta seguir los estándares del Open Group/IEEE para los resultados devueltos por C<atan2()>, pero no puede forzar a que aparezca el problema si el Perl del sistema que está corriendo no lo permite.  (Tru64, HP-UX 10.20)

La versión actual de los estándares para C<atan2()> está disponible en L<http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html>

=item binmode

No tiene sentido.  (S<RISC OS>)

Reabre el archivo y restaura el puntero; si la función falla, el identificador de archivo subyacente quizás se cierre, o el puntero estar en una posición diferente.
(VMS)

El valor devuelto por C<tell> puede quedarse afectados después de la llamada, y el identificador de archivo puede ser vaciado. (Win32)

=item chmod

Sólo bueno para cambiar el permiso de lectura/escritura del "propietario"; los bits de "grupo" y "otros" no tienen sentido. (Win32)

Sólo bueno para cambiar los permisos de lectura/escritura del "propietario" y "otros". (S<RISC OS>)

Los permisos de acceso se mapean en cambios de la lista de control de acceso VOS. (VOS)

Los permisos reales establecidos depende del valor de las configuraciones de entorno SYSTEM en C<CYGWIN>.  (Cygwin)

Establecer el bit de ejecución en algunas ubicaciones (generalmente F</sdcard>) devolverá verdadero pero de hecho no establecerá el bit. (Android)

=item chown

No se ha implementado. (Win32, S<Plan 9>, S<RISC OS>)

No hace nada, pero no fallará. (Win32)

Un poco funky, porque la de idea de propiedad de VOS es un poco funky (VOS).

=item chroot

No se ha implementado. (Win32, VMS, S<Plan 9>, S<RISC OS>, VOS)

=item crypt

Puede no estar disponible si la biblioteca o código fuente no está disponible cuando se compile perl. (Win32)

No se ha implementado. (Android)

=item dbmclose

No se ha implementado. (VMS, S<Plan 9>, VOS)

=item dbmopen

No se ha implementado. (VMS, S<Plan 9>, VOS)

=item dump

Nada útil. (S<RISC OS>)

No se admite. (Cygwin, Win32)

Invoca el depurador de VMS. (VMS)

=item exec

C<exec LISTA> sin el uso de la sintaxis de objeto indirecto (C<exec PROGRAMA LISTA>) puede terminar probando el shell si el primer C<spawn()> falla.  (Win32)

En algunas plataformas no se realiza un vaciado de los identificadores de archivo de salida.
(SunOS, Solaris, HP-UX)

No se admite. (Symbian OS)

=item exit

Emula el C<exit()> de Unix (que considera C<exit 1> como una indicación de error) mapeando el C<1> a C<SS$_ABORT> (C<44>).  Este comportamiento puede ignorarse con el I<pragma> C<use vmsish 'exit'>.  Así como la función C<exit()> de CRTL, C<exit 0> también se mapea a un estado de salida de C<SS$_NORMAL> (C<1>); este mapeo no se puede ignorar.  Cualquier otro argumento a C<exit()> se usa directamente como estado de salida de Perl.  En VMS, a menos que el futuro modo POSIX_EXIT esté activado, el código de salida debería ser siempre un código de salida VMS válido y no un número genérico.  Cuando el modo POSIX_EXIT está activado, un número genérico se codificará en un método compatible con la macro de biblioteca C _POSIX_EXIT así que se puede decodificar por otros programas, particularmente aquellos escritos en C, como el paquete GNV.  (VMS)

C<exit()> reinicia los punteros de archivo, que es un problema cuando se le llama desde un proceso hijo (creado por C<fork()>) en C<BEGIN>.
Una alterna es usar C<POSIX::_exit>.  (Solaris)

    exit unless $Config{archname} =~ /\bsolaris\b/;
    require POSIX and POSIX::_exit(0);

=item fcntl

No se ha implementado. (Win32)

Algunas funciones disponibles basadas en la versión de VMS. (VMS)

=item flock

No implementado (VMS, S<RISC OS>, VOS).

=item fork

No se ha implementado. (AmigaOS, S<RISC OS>, VMS)

Emulado usando múltiples intérpretes.  Vea L<perlfork>.  (Win32)

En algunas plataformas no se realiza un vaciado de los identificadores de archivo de salida.
(SunOS, Solaris, HP-UX)

=item getlogin

No se ha implementado. (S<RISC OS>)

=item getpgrp

No se ha implementado. (Win32, VMS, S<RISC OS>)

=item getppid

No se ha implementado. (Win32, S<RISC OS>)

=item getpriority

No se ha implementado. (Win32, VMS, S<RISC OS>, VOS)

=item getpwnam

No se ha implementado. (Win32)

Nada útil. (S<RISC OS>)

=item getgrnam

No se ha implementado. (Win32, VMS, S<RISC OS>)

=item getnetbyname

No se ha implementado. (Android, Win32, S<Plan 9>)

=item getpwuid

No se ha implementado. (Win32)

Nada útil. (S<RISC OS>)

=item getgrgid

No se ha implementado. (Win32, VMS, S<RISC OS>)

=item getnetbyaddr

No se ha implementado. (Android, Win32, S<Plan 9>)

=item getprotobynumber

No se ha implementado. (Android)

=item getservbyport

=item getpwent

No se ha implementado. (Android, Win32)

=item getgrent

No se ha implementado. (Android, Win32, VMS)

=item gethostbyname

C<gethostbyname('localhost')> no funciona en todos los sitios: puede que tenga que usar C<gethostbyname('127.0.0.1')>. (S<Irix 5>)

=item gethostent

No se ha implementado. (Win32)

=item getnetent

No se ha implementado. (Android, Win32, S<Plan 9>)

=item getprotoent

No se ha implementado. (Android, Win32, S<Plan 9>)

=item getservent

No se ha implementado. (Win32, S<Plan 9>)

=item seekdir

No se ha implementado. (Android)

=item sethostent

No se ha implementado. (Android, Win32, S<Plan 9>, S<RISC OS>)

=item setnetent

No se ha implementado. (Win32, S<Plan 9>, S<RISC OS>)

=item setprotoent

No se ha implementado. (Android, Win32, S<Plan 9>, S<RISC OS>)

=item setservent

No se ha implementado. (S<Plan 9>, Win32, S<RISC OS>)

=item endpwent

No se ha implementado. (Win32)

Tanto no implementado como una no-operación. (Android)

=item endgrent

No se ha implementado. (Android, S<RISC OS>, VMS, Win32)

=item endhostent

No se ha implementado. (Android, Win32)

=item endnetent

No se ha implementado. (Android, Win32, S<Plan 9>)

=item endprotoent

No se ha implementado. (Android, Win32, S<Plan 9>)

=item endservent

No se ha implementado. (S<Plan 9>, Win32)

=item getsockopt SOCKET,NIVEL,OPCIÓN

No se ha implementado. (S<Plan 9>)

=item glob

Este operador se implementó por medio de la extensión C<File::Glob> en la mayor parte de las plataformas.  Vea L<File::Glob> para la información sobre portabilidad.

=item gmtime

En teoría, C<gmtime()> es fiable desde -2**63 a 2**63-1.  Aun así, ya que funciona junto con la implementación de números en punto flotante, se volverá inexacto a medida de que el tiempo se haga más grande.  Esto es un error y se arreglará en el futuro.

En VOS, los valores de tiempos son cantidades de 32 bits.

=item ioctl FILEHANDLE,FUNCTION,SCALAR

No se ha implementado. (VMS)

Disponible solo para los identificadores I<socket>, y hace lo mismo que la llamada C<ioctlsocket()> en la API Winsock. (Win32)

Disponible solamente para identificadores I<socket>. (S<RISC OS>)

=item kill

No implementado, y por lo tanto no útil para comprobar la contaminación. (S<RISC OS>)

C<kill()> no tiene la semántica de C<raise()>, es decir, no envía una señal al proceso identificado como hace en las plataformas Unix.
En cambio C<kill($sig, $pid)> termina el proceso identificado por C<$pid>, y hace que salga inmediatamente con un estado de salida $sig.  Como en Unix, si $sig es 0 y el proceso especificado existe, devuelve verdadero sin realmente terminarlo. (Win32)

C<kill(-9, $pid)> terminará el proceso especificado por C<$pid> y recursivamente todos sus procesos hijo.  Esto es diferente de la semántica Unix, donde la señal se entregará a todos los procesos en el mismo grupo de proceso que el proceso especificado por $pid. (Win32)

Actualmente no está soportado el indicar un pid de -1 para todos los procesos del sistema. (VMS)

=item vínculo/vincular

No se ha implementado. (S<RISC OS>, VOS)

El contador de enlaces no se actualiza porque los enlaces duros no son lo bastante duros (son una especie de a medio camino entre enlaces duros y blandos). (AmigaOS)

Los enlaces duros están implementados en Win32 solo bajo NTFS. Están soportados nativamente en Windows 2000 y siguientes.  En Windows NT están implementados usando el soporte del subsistema POSIX para Windows y el proceso Perl necesitará tener privilegios de Administrador u Operador de Copia de seguridad para crear enlaces duros.

Disponible en OpenVMS 8.2 64 bit y siguientes.  (VMS)

=item localtime

localtime() tiene el mismo rango que L</gmtime>, pero debido a que las reglas de la zona horaria cambia su exactitud para tiempos históricos y futuros, puede degradarse, pero normalmente no más de una hora.

=item lstat

No se ha implementado. (S<RISC OS>)

Los valores de retorno (especialmente para dispositivo e inodo) pueden ser ficticios. (Win32)

=item msgctl

=item msgget

=item msgsnd

=item msgrcv

No se ha implementado. (Android, Win32, VMS, S<Plan 9>, S<RISC OS>, VOS)

=item open

No está soportado hacer un open a C<|-> y C<-|>. (Win32, S<RISC OS>)

Abrir un proceso no vacía automáticamente los identificadores de salida en algunas plataformas.  (SunOS, Solaris, HP-UX)

=item readlink

No se ha implementado. (Win32, VMS, S<RISC OS>)

=item rename

No puedo mover directorios entre directorios en diferentes volúmenes lógicos. (Win32)

=item rewinddir

No hará que C<readdir()> relea el flujo del directorio.  Las entradas ya leídas antes de la llamada C<rewinddir()> se devolverán otra vez del búfer cacheado. (Win32)

=item select

Solo implementado en I<sockets>. (Win32, VMS)

Solo fiable en I<sockets>. (S<RISC OS>)

Note que la forma C<select FILEHANDLE> está portada de forma general.

=item semctl

=item semget

=item semop

No se ha implementado. (Android, Win32, VMS, S<RISC OS>)

=item setgrent

No se ha implementado. (Android, VMS, Win32, S<RISC OS>)

=item setpgrp

No se ha implementado. (Win32, VMS, S<RISC OS>, VOS)

=item setpriority

No se ha implementado. (Win32, VMS, S<RISC OS>, VOS)

=item setpwent

No se ha implementado. (Android, Win32, S<RISC OS>)

=item setsockopt

No se ha implementado. (S<Plan 9>)

=item shmctl

=item shmget

=item shmread

=item shmwrite

No se ha implementado. (Android, Win32, VMS, S<RISC OS>)

=item sleep

Emulado usando funciones de sincronización que pueden ser interrumpidas por C<alarm()>, y limitada a un máximo de 4294967 segundos, aproximadamente 49 días. (Win32)

=item sockatmark

Un relativamente reciente adición a las funciones I<socket>, puede no estar implementado incluso en plataformas Unix.

=item socketpair

No se ha implementado. (S<RISC OS>)

Disponible en OpenVMS 8.2 64 bit y siguientes.  (VMS)

=item stat

Plataformas que no tienen rdev, blksize, o blocks devolverán estos valores como '', así que una comparación numérica o manipulación de estos campos puede provocar advertencias del tipo 'no numérico'.

ctime no está soportada en UFS (S<Mac OS X>).

ctime es el tiempo de creación en lugar del tiempo de cambio del inodo (Win32).

dispositivo e inodo no son significativos.  (Win32)

dispositivo e inodo no son necesariamente fiables.  (VMS)

mtime, atime y ctime devuelven el último tiempo de modificación.  Dispositivo e inodo no son necesariamente fiables.  (S<RISC OS>)

dev, rdev, blksize y blocks no están disponibles.  inodo no es significativo y deferirá entre llamadas stat sobre el mismo archivo.  (os2)

Algunas versiones de cygwin al hacer un C<stat("foo")> y no encontrarlo pueden entonces intentarlo con C<stat("foo.exe")>. (Cygwin)

En Win32 C<stat()> necesita abrir el archivo para determinar el contador de enlaces y actualizar los atributos que pueden haber cambiado a través de los enlaces duros.
Establecer C<${^WIN32_SLOPPY_STAT}> a un valor verdadero acelera C<stat()> al no realizar esta operación. (Win32)

=item symlink

No se ha implementado. (Win32, S<RISC OS>)

Implementado en 64 bit VMS 8.3.  VMS requiere que el enlace simbólico tenga una sintaxis Unix si se pretende que resuelva a una ruta válida.

=item llamada de sistema

No se ha implementado. (Win32, VMS, S<RISC OS>, VOS)

=item sysopen

Los tradicionales MODOs "0", "1" y "2" se implementan con valores numéricos diferentes en algunos sistemas.  Aún así los indicadores exportados por C<Fcntl> (O_RDONLY, O_WRONLY, O_RDWR) deberían funcionar en todos los sitios.  (S<Mac OS>, OS/390)

=item system

Como optimización, puede no llamar al shell de comandos especificado en C<$ENV{PERL5SHELL}>.  C<system(1, @args)> se desdobla en un proceso externo e inmediatamente regresa a su proceso padre, sin esperar a que termine.  El valor de retorno se puede usar posteriormente en C<wait> o C<waitpid>.  Un fallo en desdoblar un subproceso con C<spawn()> se indica estableciendo C<$?> a S<C<"255 << 8">>.  C<$?> se establece de una forma compatible con Unix (por ejemplo, el estado de salida del subproceso se obtiene de S<C<"$? >> 8">>, como se describe en la documentación).  (Win32)

No hay un shell que procese metacaracteres, y el estándar nativo es pasar una línea de comandos terminada por "\n" "\r" o "\0" para desdoblar el programa.  La redirección como en C<< > foo >> se realiza (de forma absoluta) por la biblioteca de ejecución en tiempo real por el programa desdoblado.  C<system> I<lista> llamará a la emulación de C<exec> de la biblioteca de emulación, que intenta proporcionar emulación de stdin, stdout, stderr en vigor en el padre, proporcionando el programa hijo que usa una versión compatible de la biblioteca de emulación.
I<scalar> llamará directamente al comando en línea nativo y no existirá emulación de un programa Unix hijo.  Las formas B<variarán>.  (S<RISC OS>)

C<system LISTA> sin el uso de la sintaxis de objeto indirecto (C<system PROGRAMA LISTA>) puede terminar probando el shell si el primer C<spawn()> falla.  (Win32)

En algunas plataformas no se realiza un vaciado de los identificadores de archivo de salida.
(SunOS, Solaris, HP-UX)

El valor de retorno es parecido a POSIX (desplazado hacia arriba por 8 bits), que solo permite espacio para un valor fabricado derivado de los bits de severidad del código de condición nativo de 32 bits (a menos que se sobreescriban con C<use vmsish 'status'>).
Si el código de condición nativo es uno que tiene un valor codificado POSIX, el valor POSIX se decodificará para extraer el valor de salida esperado.
Para más detalles vea L<perlvms/$?>. (VMS)

=item telldir

No se ha implementado. (Android)

=item times

tiempos "acumulados" serán ficticios.  En cualquier otro que sea Windows NT o Windows 2000, el tiempo del "sistema" será ficticio, y el tiempo de "usuario" es de hecho el tiempo devuelto por la función C<clock()> de la biblioteca de tiempo de ejecución de C. (Win32)

Nada útil. (S<RISC OS>)

=item truncate

No se ha implementado. (Antiguas versiones de VMS)

Solo trunca a longitudes que sean iguales o más cortos. (VOS)

Si se suministra un IDENTIFICADOR DE ARCHIVO, debe ser escribible y abierto en modo añadir (por ejemplo, use C<<< open(FH, '>>nombre-de-archivo') >>> o C<sysopen(FH,...,O_APPEND|O_RDWR)>.  Si se suministra un nombre de archivo, no debería estar ya abierto. (Win32)

=item umask

Devuelve undef donde no esté disponible.

C<umask> funciona pero los permisos correctos se establecen cuando el archivo finalmente se cierra. (AmigaOS)

=item utime

Solamente se actualiza el tiempo de modificación. (VMS, S<RISC OS>)

Puede no comportarse como se espera.  El comportamiento depende de la implementación de la biblioteca de tiempo de ejecución de C de C<utime()>, y el sistema de archivos utilizado.  El sistema de archivos FAT no soporta, típicamente un campo de "tiempo de acceso", y puede limitar los sellos de tiempo a una granularidad de dos segundos. (Win32)

=item wait

=item waitpid

Sólo se puede aplicar a identificadores de proceso devueltos por procesos desdoblados usando C<system(1, ...)> o pseudo procesos creados con C<fork()>. (Win32)

Nada útil. (S<RISC OS>)

=back


=head1 Plataformas compatibles

De las siguientes plataformas se sabe que compilan Perl 5.12 (de abril de 2010, su fecha de distribución) desde la distribución de código fuente estándar disponible en L<http://www.cpan.org/src>

=over

=item Linux (x86, ARM, IA64)

=item HP-UX

=item AIX

=item Win32

=over

=item Windows 2000

=item Windows XP

=item Windows Server 2003

=item Windows Vista

=item Windows Server 2008

=item Windows 7

=back

=item Cygwin

Algunas pruebas se sabe que fallan:

=over

=item *

F<ext/XS-APItest/t/call_checker.t> - vea L<https://rt.perl.org/Ticket/Display.html?id=78502>

=item *

F<dist/I18N-Collate/t/I18N-Collate.t>

=item *

F<ext/Win32CORE/t/win32core.t> - puede fallar en instalaciones recientes de cygwin.

=back

=item Solaris (x86, SPARC)

=item OpenVMS

=over

=item Alpha (7.2 y siguientes)

=item I64 (8.2 y siguientes)

=back

=item Symbian

=item NetBSD

=item FreeBSD

=item Debian GNU/kFreeBSD

=item Haiku

=item Irix (6.5. ¿Qué si no?)

=item OpenBSD

=item Dragonfly BSD

=item Midnight BSD

=item QNX Neutrino RTOS (6.5.0)

=item MirOS BSD

=item Stratus OpenVOS (17.0 o siguientes)

Problemas:

=over

=item problemas con time_t que pueden o no estar arreglados

=back

=item Symbian (Series 60 v3, 3.2 y 5 - ¿Qué si no?)

=item Stratus VOS / OpenVOS

=item AIX

=item Android

=item FreeMINT

Perl ahora compila en FreeMiNT/Atari. Falla unas pocas pruebas, que necesitan alguna investigación.

La adaptación FreeMiNT usa GNU dld para las capacidades de cargar módulos. Así que asegúrese que tiene la biblioteca instalada cuando compile perl.

=back

=head1 Plataformas EOL

=head2 (Perl 5.20)

Las siguientes plataformas se soportaron por una versión anterior de Perl pero que han sido oficialmente eliminadas del código fuente de Perl a partir de 5.20:

=over

=item AT&T 3b1

=back

=head2 (Perl 5.14)

Las siguientes plataformas se soportaban hasta 5.10.  Pueden seguir funcionando en 5.12, pero el soporte del código se eliminó en 5.14:

=over

=item Windows 95

=item Windows 98

=item Windows ME

=item Windows NT4

=back

=head2 (Perl 5.12)

Las siguientes plataformas se soportaron por una versión anterior de Perl pero que han sido oficialmente eliminadas del código fuente de Perl a partir de 5.12:

=over

=item Atari MiNT

=item Apollo Domain/OS

=item Apple Mac OS 8/9

=item Tenon Machten

=back


=head1 Plataformas soportadas (Perl 5.8)

En julio de 2002 (la distribución de 5.8.0), las siguientes plataformas fueron capaces de compilar Perl desde la distribución de código fuente estándar disponible en L<http://www.cpan.org/src/>

        AIX
        BeOS
        BSD/OS          (BSDi)
        Cygwin
        DG/UX
        DOS DJGPP       1)
        DYNIX/ptx
        EPOC R5
        FreeBSD
        HI-UXMPP        (Hitachi) (5.8.0 funcionaba pero no lo sabíamos)
        HP-UX
        IRIX
        Linux
        Mac OS Classic
        Mac OS X        (Darwin)
        MPE/iX
        NetBSD
        NetWare
        NonStop-UX
        ReliantUNIX     (anteriormente SINIX)
        OpenBSD
        OpenVMS         (anteriormente VMS)
        Open UNIX       (Unixware) (desde Perl 5.8.1/5.9.0)
        OS/2
        OS/400          (usando el PASE) (desde Perl 5.8.1/5.9.0)
        PowerUX
        POSIX-BC        (anteriormente BS2000)
        QNX
        Solaris
        SunOS 4
        SUPER-UX        (NEC)
        Tru64 UNIX      (anteriormente DEC OSF/1, Digital UNIX)
        UNICOS
        UNICOS/mk
        UTS
        VOS / OpenVOS
        Win95/98/ME/2K/XP 2)
        WinCE
        z/OS            (anteriormente OS/390)
        VM/ESA

        1) en modo DOS se pueden usar tanto adaptaciones DOS como OS/2
        2) compiladores: Borland, MinGW (GCC), VC6

Las siguientes plataformas han funcionado con distribuciones anteriores (5.6 y 5.7), pero no gestionamos ni el arreglo ni las pruebas de éstas en el momento de la distribución de 5.8.0.  Hay muchas posibilidades de que muchas de éstas funcionen bien con 5.8.0.

        BSD/OS
        DomainOS
        Hurd
        LynxOS
        MachTen
        PowerMAX
        SCO SV
        SVR4
        Unixware
        Windows 3.1

Se sabe que no funciona para 5.8.0 (pero se pueden usar 5.6.1 y 5.7.2):

	AmigaOS 3

De las siguientes plataformas se sabe que compilan Perl desde el código fuente en el pasado (5.005_03 y anteriores), pero no hemos sido capaces de verificar su estado para la distribución actual, tanto porque las plataformas hardware/software son raros o porque no tenemos un campeón activo en estas plataformas, o ambos.  Están preparadas para funcionar, así que, adelante e intente compilarlas, y mande cualquier problema a perlbug@perl.org

        3b1
        A/UX
        ConvexOS
        CX/UX
        DC/OSx
        DDE SMES
        DOS EMX
        Dynix
        EP/IX
        ESIX
        FPS
        GENIX
        Greenhills
        ISC
        MachTen 68k
        MPC
        NEWS-OS
        NextSTEP
        OpenSTEP
        Opus
        Plan 9
        RISC/os
        SCO ODT/OSR
        Stellar
        SVR2
        TI1500
        TitanOS
        Ultrix
        Unisys Dynix

Las siguientes plataformas tienen su propia distribución de código fuente y binarios disponible a través de L<http://www.cpan.org/ports/>

                                Distribución Perl

        OS/400 (ILE)            5.005_02
        Tandem Guardian         5.004

Las siguientes plataformas sólo tienen disponibles los binarios a través de L<http://www.cpan.org/ports/index.html> :

                                Distribución Perl

        Acorn RISCOS            5.005_02
        AOS                     5.002
        LynxOS                  5.004_02

Aunque sugerimos que siempre compile su propio Perl desde el código fuente, tanto por máxima capacidad de configuración y por seguridad, en caso de urgencia puede entrar en L<http://www.cpan.org/ports/index.html> para encontrar distribuciones binarias.

=head1 VEA TAMBIÉN

L<perlaix>, L<perlamiga>, L<perlbs2000>,
L<perlce>, L<perlcygwin>, L<perldos>,
L<perlebcdic>, L<perlfreebsd>, L<perlhurd>, L<perlhpux>, L<perlirix>,
L<perlmacos>, L<perlmacosx>,
L<perlnetware>, L<perlos2>, L<perlos390>, L<perlos400>,
L<perlplan9>, L<perlqnx>, L<perlsolaris>, L<perltru64>,
L<perlunicode>, L<perlvms>, L<perlvos>, L<perlwin32> y L<Win32>.

=head1 AUTORES / CONTRIBUYENTES

Abigail <abigail@foad.org>,
Charles Bailey <bailey@newman.upenn.edu>,
Graham Barr <gbarr@pobox.com>,
Tom Christiansen <tchrist@perl.com>,
Nicholas Clark <nick@ccl4.org>,
Thomas Dorner <Thomas.Dorner@start.de>,
Andy Dougherty <doughera@lafayette.edu>,
Dominic Dunlop <domo@computer.org>,
Neale Ferguson <neale@vma.tabnsw.com.au>,
David J. Fiander <davidf@mks.com>,
Paul Green <Paul.Green@stratus.com>,
M.J.T. Guy <mjtg@cam.ac.uk>,
Jarkko Hietaniemi <jhi@iki.fi>,
Luther Huffman <lutherh@stratcom.com>,
Nick Ing-Simmons <nick@ing-simmons.net>,
Andreas J. KE<ouml>nig <a.koenig@mind.de>,
Markus Laker <mlaker@contax.co.uk>,
Andrew M. Langmead <aml@world.std.com>,
Larry Moore <ljmoore@freespace.net>,
Paul Moore <Paul.Moore@uk.origin-it.com>,
Chris Nandor <pudge@pobox.com>,
Matthias Neeracher <neeracher@mac.com>,
Philip Newton <pne@cpan.org>,
Gary Ng <71564.1743@CompuServe.COM>,
Tom Phoenix <rootbeer@teleport.com>,
AndrE<eacute> Pirard <A.Pirard@ulg.ac.be>,
Peter Prymmer <pvhp@forte.com>,
Hugo van der Sanden <hv@crypt0.demon.co.uk>,
Gurusamy Sarathy <gsar@activestate.com>,
Paul J. Schinder <schinder@pobox.com>,
Michael G Schwern <schwern@pobox.com>,
Dan Sugalski <dan@sidhe.org>,
Nathan Torkington <gnat@frii.com>,
John Malmberg <wb8tyw@qsl.net>
